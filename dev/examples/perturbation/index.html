<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl</title><meta name="title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta property="og:title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta property="twitter:title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/examples/perturbation/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/examples/perturbation/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/examples/perturbation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Mixed Symbolic-Numeric Perturbation Theory</a><ul class="internal"><li><a class="tocitem" href="#Background"><span>Background</span></a></li><li><a class="tocitem" href="#Solving-the-Quintic"><span>Solving the Quintic</span></a></li><li><a class="tocitem" href="#Solving-the-Kepler&#39;s-Equation"><span>Solving the Kepler&#39;s Equation</span></a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../../manual/expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../../manual/derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../../manual/groebner/">Groebner bases</a></li><li><a class="tocitem" href="../../manual/arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../../manual/build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../../manual/functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../../manual/parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../../manual/io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../../manual/sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../../manual/types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Mixed Symbolic-Numeric Perturbation Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/examples/perturbation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="perturb_alg"><a class="docs-heading-anchor" href="#perturb_alg">Mixed Symbolic-Numeric Perturbation Theory</a><a id="perturb_alg-1"></a><a class="docs-heading-anchor-permalink" href="#perturb_alg" title="Permalink"></a></h1><h2 id="Background"><a class="docs-heading-anchor" href="#Background">Background</a><a id="Background-1"></a><a class="docs-heading-anchor-permalink" href="#Background" title="Permalink"></a></h2><p><a href="https://github.com/JuliaSymbolics/Symbolics.jl"><strong>Symbolics.jl</strong></a> is a fast and modern Computer Algebra System (CAS) written in the Julia Programming Language. It is an integral part of the <a href="https://sciml.ai/">SciML</a> ecosystem of differential equation solvers and scientific machine learning packages. While <strong>Symbolics.jl</strong> is primarily designed for modern scientific computing (e.g., auto-differentiation, machine learning), it is a powerful CAS that can also be useful for <em>classic</em> scientific computing. One such application is using the <em>perturbation</em> theory to solve algebraic and differential equations.</p><p>Perturbation methods are a collection of techniques to solve intractable problems that generally don&#39;t have a closed solution but depend on a tunable parameter and have closed or easy solutions for some values of the parameter. The main idea is to assume a solution as a power series in the tunable parameter (say <span>$ϵ$</span>), such that <span>$ϵ = 0$</span> corresponds to an easy solution.</p><p>We will discuss the general steps of the perturbation methods to solve algebraic (this tutorial) and <a href="@ref perturb_diff">differential equations</a></p><p>The hallmark of the perturbation method is the generation of long and convoluted intermediate equations, which are subjected to algorithmic and mechanical manipulations. Therefore, these problems are well suited for CAS. In fact, CAS software packages have been used to help with the perturbation calculations since the early 1970s.</p><p>In this tutorial, our goal is to show how to use a mix of symbolic manipulations (<strong>Symbolics.jl</strong>) and numerical methods to solve simple perturbation problems.</p><h2 id="Solving-the-Quintic"><a class="docs-heading-anchor" href="#Solving-the-Quintic">Solving the Quintic</a><a id="Solving-the-Quintic-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Quintic" title="Permalink"></a></h2><p>We start with the “hello world!” analog of the perturbation problems, solving the quintic (fifth-order) equations. We want to find a real valued <span>$x$</span> such that <span>$x^5 + x = 1$</span>. According to the Abel&#39;s theorem, a general quintic equation does not have a closed form solution. Of course, we can easily solve this equation numerically; for example, by using the Newton&#39;s method. We use the following implementation of the Newton&#39;s method:</p><pre><code class="language-julia hljs">using Symbolics, SymbolicUtils

function solve_newton(f, x, x₀; abstol=1e-8, maxiter=50)
    xₙ = Float64(x₀)
    fₙ₊₁ = x - f / Symbolics.derivative(f, x)

    for i = 1:maxiter
        xₙ₊₁ = substitute(fₙ₊₁, Dict(x =&gt; xₙ))
        if abs(xₙ₊₁ - xₙ) &lt; abstol
            return xₙ₊₁
        else
            xₙ = xₙ₊₁
        end
    end
    return xₙ₊₁
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_newton (generic function with 1 method)</code></pre><p>In this code, <code>Symbolics.derivative(eq, x)</code> does exactly what it names implies: it calculates the symbolic derivative of <code>eq</code> (a <strong>Symbolics.jl</strong> expression) with respect to <code>x</code> (a <strong>Symbolics.jl</strong> variable). We use <code>Symbolics.substitute(eq, D)</code> to evaluate the update formula by substituting variables or sub-expressions (defined in a dictionary <code>D</code>) in <code>eq</code>. It should be noted that <code>substitute</code> is the workhorse of our code and will be used multiple times in the rest of these tutorials. <code>solve_newton</code> is written with simplicity and clarity in mind, and not performance.</p><p>Let&#39;s go back to our quintic. We can define a Symbolics variable as <code>@variables x</code> and then solve the equation <code>solve_newton(x^5 + x - 1, x, 1.0)</code> (here, <code>x₀ = 0</code> is our first guess). The answer is 0.7549. Now, let&#39;s see how we can solve the same problem using the perturbation methods.</p><p>We introduce a tuning parameter <span>$\epsilon$</span> into our equation: <span>$x^5 + \epsilon x = 1$</span>. If <span>$\epsilon = 1$</span>, we get our original problem. For <span>$\epsilon = 0$</span>, the problem transforms to an easy one: <span>$x^5 = 1$</span> which has an exact real solution <span>$x = 1$</span> (and four complex solutions which we ignore here). We expand <span>$x$</span> as a power series on <span>$\epsilon$</span>:</p><p class="math-container">\[  x(\epsilon) = a_0 + a_1 \epsilon + a_2 \epsilon^2 + O(\epsilon^3)\]</p><p class="math-container">\[a_0\]</p><p>is the solution of the easy equation, therefore <span>$a_0 = 1$</span>. Substituting into the original problem,</p><p class="math-container">\[  (a_0 + a_1 \epsilon + a_2 \epsilon^2)^5 + \epsilon (a_0 + a_1 \epsilon + a_2 \epsilon^2) - 1 = 0\]</p><p>Expanding the equations, we get</p><p class="math-container">\[  \epsilon (1 + 5 a_1) + \epsilon^2 (a_1 + 5 a_2 + 10 a1_2) + 𝑂(\epsilon^3) = 0\]</p><p>This equation should hold for each power of <span>$\epsilon$</span>. Therefore,</p><p class="math-container">\[  1 + 5 a_1 = 0\]</p><p>and</p><p class="math-container">\[  a_1 + 5 a_2 + 10 a_1^2 = 0\]</p><p>This system of equations does not initially seem to be linear because of the presence of terms like <span>$10 a_1^2$</span>, but upon closer inspection is found to be linear (this is a feature of the perturbation methods). In addition, the system is in a triangular form, meaning the first equation depends only on <span>$a_1$</span>, the second one on <span>$a_1$</span> and <span>$a_2$</span>, such that we can replace the result of <span>$a_1$</span> from the first one into the second equation and remove the non-linear term. We solve the first equation to get <span>$a_1 = -\frac{1}{5}$</span>. Substituting in the second one and solve for <span>$a_2$</span>:</p><p class="math-container">\[  a_2 = \frac{(-\frac{1}{5} + 10(-(\frac{1}{5})²)}{5}  = -\frac{1}{25}\]</p><p>Finally,</p><p class="math-container">\[  x(\epsilon) = 1 - \frac{\epsilon}{5} - \frac{\epsilon^2}{25} + O(\epsilon^3)\]</p><p>Solving the original problem, <span>$x(1) = 0.76$</span>, compared to 0.7548 calculated numerically. We can improve the accuracy by including more terms in the expansion of <span>$x$</span>. However, the calculations, while straightforward, become messy and intractable to do manually very quickly. This is why a CAS is very helpful to solve perturbation problems.</p><p>Now, let&#39;s see how we can do these calculations in Julia. Let <span>$n$</span> be the order of the expansion. We start by defining the symbolic variables:</p><pre><code class="language-julia hljs">n = 2
@variables ϵ a[1:n]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
 ϵ
  a[1:2]</code></pre><p>Then, we define</p><pre><code class="language-julia hljs">x = 1 + a[1]*ϵ + a[2]*ϵ^2</code></pre><p class="math-container">\[ \begin{equation}
1 + a_1 \epsilon + \epsilon^{2} a_2
\end{equation}
 \]</p><p>The next step is to substitute <code>x</code> in the problem equation</p><pre><code class="language-julia hljs">  eq = x^5 + ϵ*x - 1</code></pre><p class="math-container">\[ \begin{equation}
-1 + \left( 1 + a_1 \epsilon + \epsilon^{2} a_2 \right) \epsilon + \left( 1 + a_1 \epsilon + \epsilon^{2} a_2 \right)^{5}
\end{equation}
 \]</p><p>The expanded form of <code>eq</code> is</p><pre><code class="language-julia hljs">expand(eq)</code></pre><p class="math-container">\[ \begin{equation}
\epsilon + 5 a_1 \epsilon + \epsilon^{2} a_1 + 5 \epsilon^{2} a_2 + 10 \epsilon^{2} a_1^{2} + \epsilon^{3} a_2 + 20 \epsilon^{3} a_1 a_2 + 10 \epsilon^{3} a_1^{3} + 10 \epsilon^{4} a_2^{2} + 30 \epsilon^{4} a_1^{2} a_2 + 5 \epsilon^{4} a_1^{4} + 30 \epsilon^{5} a_2^{2} a_1 + 20 \epsilon^{5} a_1^{3} a_2 + 10 \epsilon^{6} a_2^{3} + \epsilon^{5} a_1^{5} + 30 \epsilon^{6} a_2^{2} a_1^{2} + 5 \epsilon^{6} a_1^{4} a_2 + 20 \epsilon^{7} a_2^{3} a_1 + 10 \epsilon^{7} a_2^{2} a_1^{3} + 5 \epsilon^{8} a_2^{4} + 10 \epsilon^{8} a_2^{3} a_1^{2} + 5 \epsilon^{9} a_2^{4} a_1 + \epsilon^{10} a_2^{5}
\end{equation}
 \]</p><p>We need a way to get the coefficients of different powers of <code>ϵ</code>. Function <code>collect_powers(eq, x, ns)</code> returns the powers of variable <code>x</code> in expression <code>eq</code>. Argument <code>ns</code> is the range of the powers.</p><pre><code class="language-julia hljs">function collect_powers(eq, x, ns; max_power=100)
    eq = substitute(expand(eq), Dict(x^j =&gt; 0 for j=last(ns)+1:max_power))

    eqs = []
    for i in ns
        powers = Dict(x^j =&gt; (i==j ? 1 : 0) for j=1:last(ns))
        push!(eqs, substitute(eq, powers))
    end
    eqs
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">collect_powers (generic function with 1 method)</code></pre><p>To return the coefficients of <span>$ϵ$</span> and <span>$ϵ^2$</span> in <code>eq</code>, we can write</p><pre><code class="language-julia hljs">eqs = collect_powers(eq, ϵ, 1:2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Any}:
                 1 + 5a[1]
 a[1] + 5a[2] + 10(a[1]^2)</code></pre><p>A few words on how <code>collect_powers</code> works, It uses <code>substitute</code> to find the coefficient of a given power of <code>x</code> by passing a <code>Dict</code> with all powers of <code>x</code> set to 0, except the target power which is set to 1. For example, the following expression returns the coefficient of <code>ϵ^2</code> in <code>eq</code>,</p><pre><code class="language-julia hljs">substitute(expand(eq), Dict(
  ϵ =&gt; 0,
  ϵ^2 =&gt; 1,
  ϵ^3 =&gt; 0,
  ϵ^4 =&gt; 0,
  ϵ^5 =&gt; 0,
  ϵ^6 =&gt; 0,
  ϵ^7 =&gt; 0,
  ϵ^8 =&gt; 0)
)</code></pre><p class="math-container">\[ \begin{equation}
a_1 + 5 a_2 + 10 a_1^{2}
\end{equation}
 \]</p><p>Back to our problem. Having the coefficients of the powers of <code>ϵ</code>, we can set each equation in <code>eqs</code> to 0 (remember, we rearrange the problem such that <code>eq</code> is 0) and solve the system of linear equations to find the numerical values of the coefficients. <strong>Symbolics.jl</strong> has a function <code>Symbolics.solve_for</code> that can solve systems of linear equations. However, the presence of higher-order terms in <code>eqs</code> prevents <code>Symbolics.solve_for(eqs .~ 0, a)</code> from workings properly. Instead, we can exploit the fact that our system is in a triangular form and start by solving <code>eqs[1]</code> for <code>a₁</code> and then substitute this in <code>eqs[2]</code> and solve for <code>a₂</code>, and so on.  This <em>cascading</em> process is done by function <code>solve_coef(eqs, ps)</code>:</p><pre><code class="language-julia hljs">function solve_coef(eqs, ps)
    vals = Dict()

    for i = 1:length(ps)
        eq = substitute(eqs[i], vals)
        vals[ps[i]] = Symbolics.solve_for(eq ~ 0, ps[i])
    end
    vals
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_coef (generic function with 1 method)</code></pre><p>Here, <code>eqs</code> is an array of expressions (assumed to be equal to 0) and <code>ps</code> is an array of variables. The result is a dictionary of <em>variable</em> =&gt; <em>value</em> pairs. We apply <code>solve_coef</code> to <code>eqs</code> to get the numerical values of the parameters:</p><pre><code class="language-julia hljs">solve_coef(eqs, a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 2 entries:
  a[2] =&gt; -0.04
  a[1] =&gt; -0.2</code></pre><p>Finally, we substitute back the values of <code>a</code> in the definition of <code>x</code> as a function of <code>𝜀</code>. Note that <code>𝜀</code> is a number (usually Float64), whereas <code>ϵ</code> is a symbolic variable.</p><pre><code class="language-julia hljs">X = 𝜀 -&gt; 1 + a[1]*𝜀 + a[2]*𝜀^2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#7 (generic function with 1 method)</code></pre><p>Therefore, the solution to our original problem becomes <code>X(1)</code>, which is equal to 0.76. We can use larger values of <code>n</code> to improve the accuracy of estimations.</p><table><tr><th style="text-align: right">n</th><th style="text-align: right">x</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">0.8</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">0.76</td></tr><tr><td style="text-align: right">3</td><td style="text-align: right">0.752</td></tr><tr><td style="text-align: right">4</td><td style="text-align: right">0.752</td></tr><tr><td style="text-align: right">5</td><td style="text-align: right">0.7533</td></tr><tr><td style="text-align: right">6</td><td style="text-align: right">0.7543</td></tr><tr><td style="text-align: right">7</td><td style="text-align: right">0.7548</td></tr><tr><td style="text-align: right">8</td><td style="text-align: right">0.7550</td></tr></table><p>Remember, the numerical value is 0.7549. The two functions <code>collect_powers</code> and <code>solve_coef(eqs, a)</code> are used in all the examples in this and the next tutorial.</p><h2 id="Solving-the-Kepler&#39;s-Equation"><a class="docs-heading-anchor" href="#Solving-the-Kepler&#39;s-Equation">Solving the Kepler&#39;s Equation</a><a id="Solving-the-Kepler&#39;s-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Kepler&#39;s-Equation" title="Permalink"></a></h2><p>Historically, the perturbation methods were first invented to solve orbital calculations of the Moon and the planets. In homage to this history, our second example has a celestial theme. Our goal is solving the Kepler&#39;s equation:</p><p class="math-container">\[  E - e\sin(E) = M\]</p><p>where <span>$e$</span> is the <em>eccentricity</em> of the elliptical orbit, <span>$M$</span> is the <em>mean anomaly</em>, and <span>$E$</span> (unknown) is the <em>eccentric anomaly</em> (the angle between the position of a planet in an elliptical orbit and the point of periapsis). This equation is central to solving two-body Keplerian orbits.</p><p>Similar to the first example, it is easy to solve this problem using the Newton&#39;s method. For example, let <span>$e = 0.01671$</span> (the eccentricity of the Earth) and <span>$M = \pi/2$</span>. We have <code>solve_newton(x - e*sin(x) - M, x, M)</code> equals to 1.5875 (compared to π/2 = 1.5708). Now, we try to solve the same problem using the perturbation techniques (see function <code>test_kepler</code>).</p><p>For <span>$e = 0$</span>, we get <span>$E = M$</span>. Therefore, we can use <span>$e$</span> as our perturbation parameter. For consistency with other problems, we also rename <span>$e$</span> to <span>$\epsilon$</span> and <span>$E$</span> to <span>$x$</span>.</p><p>From here on, we use the helper function <code>def_taylor</code> to define Taylor&#39;s series by calling it as <code>x = def_taylor(ϵ, a, 1)</code>, where the arguments are, respectively, the perturbation variable, which is an array of coefficients (starting from the coefficient of <span>$\epsilon^1$</span>), and an optional constant term.</p><pre><code class="language-julia hljs">def_taylor(x, ps) = sum([a*x^i for (i,a) in enumerate(ps)])
def_taylor(x, ps, p₀) = p₀ + def_taylor(x, ps)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">def_taylor (generic function with 2 methods)</code></pre><p>We start by defining the variables (assuming <code>n = 3</code>):</p><pre><code class="language-julia hljs">n = 3
@variables ϵ M a[1:n]
x = def_taylor(ϵ, a, M)</code></pre><p class="math-container">\[ \begin{equation}
M + a_1 \epsilon + \epsilon^{2} a_2 + \epsilon^{3} a_3
\end{equation}
 \]</p><p>We further simplify by substituting <code>sin</code> with its power series using the <code>expand_sin</code> helper function:</p><pre><code class="language-julia hljs">expand_sin(x, n) = sum([(isodd(k) ? -1 : 1)*(-x)^(2k-1)/factorial(2k-1) for k=1:n])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">expand_sin (generic function with 1 method)</code></pre><p>To test,</p><pre><code class="language-julia hljs">expand_sin(0.1, 10) ≈ sin(0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>The problem equation is</p><pre><code class="language-julia hljs">eq = x - ϵ * expand_sin(x, n) - M</code></pre><p class="math-container">\[ \begin{equation}
a_1 \epsilon + \epsilon^{2} a_2 + \epsilon^{3} a_3 - \left( M + a_1 \epsilon + \epsilon^{2} a_2 + \epsilon^{3} a_3 + \frac{1}{6} \left(  - M - a_1 \epsilon - \epsilon^{2} a_2 - \epsilon^{3} a_3 \right)^{3} - \frac{1}{120} \left(  - M - a_1 \epsilon - \epsilon^{2} a_2 - \epsilon^{3} a_3 \right)^{5} \right) \epsilon
\end{equation}
 \]</p><p>We follow the same process as the first example. We collect the coefficients of the powers of <code>ϵ</code></p><pre><code class="language-julia hljs">eqs = collect_powers(eq, ϵ, 1:n)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
                                                          -M + a[1] + (1//6)*(M^3) - (1//120)*(M^5)
                                              -a[1] + a[2] + (1//2)*(M^2)*a[1] - (1//24)*(M^4)*a[1]
 -a[2] + a[3] + (1//2)*(M^2)*a[2] + (1//2)*M*(a[1]^2) - (1//24)*(M^4)*a[2] - (1//12)*(M^3)*(a[1]^2)</code></pre><p>and then solve for <code>a</code>:</p><pre><code class="language-julia hljs">vals = solve_coef(eqs, a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 3 entries:
  a[2] =&gt; M - (1//6)*(M^3) + (1//120)*(M^5) - (1//2)*(M^2)*(M - (1//6)*(M^3) + …
  a[3] =&gt; M - (1//6)*(M^3) + (1//120)*(M^5) - (1//2)*(M^2)*(M - (1//6)*(M^3) + …
  a[1] =&gt; M - (1//6)*(M^3) + (1//120)*(M^5)</code></pre><p>Finally, we substitute <code>vals</code> back in <code>x</code>:</p><pre><code class="language-julia hljs">x′ = substitute(x, vals)
X = (𝜀, 𝑀) -&gt; substitute(x′, Dict(ϵ =&gt; 𝜀, M =&gt; 𝑀))
X(0.01671, π/2)</code></pre><p class="math-container">\[ \begin{equation}
1.5876
\end{equation}
 \]</p><p>The result is 1.5876, compared to the numerical value of 1.5875. It is customary to order <code>X</code> based on the powers of <code>𝑀</code> instead of <code>𝜀</code>. We can calculate this series as <code>collect_powers(sol, M, 0:3)</code>. The result (after manual cleanup) is</p><pre><code class="nohighlight hljs">(1 + 𝜀 + 𝜀^2 + 𝜀^3)*𝑀
- (𝜀 + 4*𝜀^2 + 10*𝜀^3)*𝑀^3/6
+ (𝜀 + 16*𝜀^2 + 91*𝜀^3)*𝑀^5/120</code></pre><p>Comparing the formula to the one for 𝐸 in the <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation">Wikipedia article on the Kepler&#39;s equation</a>:</p><p class="math-container">\[  E = \frac{1}{1-\epsilon}M
    -\frac{\epsilon}{(1-\epsilon)^4} \frac{M^3}{3!} + \frac{(9\epsilon^2
    + \epsilon)}{(1-\epsilon)^7}\frac{M^5}{5!}\cdots\]</p><p>The first deviation is in the coefficient of <span>$\epsilon^3 M^5$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/converting_to_C/">« Automatic Conversion of Julia Code to C Functions</a><a class="docs-footer-nextpage" href="../../manual/variables/">Variable and Equation Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 14 March 2024 13:53">Thursday 14 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
