<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variable and Equation Types · Symbolics.jl</title><meta name="title" content="Variable and Equation Types · Symbolics.jl"/><meta property="og:title" content="Variable and Equation Types · Symbolics.jl"/><meta property="twitter:title" content="Variable and Equation Types · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/variables/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/variables/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/variables/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li><a class="tocitem" href="../../tutorials/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Variable and Equation Types</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#A-note-about-functions-restricted-to-Numbers"><span>A note about functions restricted to <code>Number</code>s</span></a></li><li><a class="tocitem" href="#Symbolic-Control-Flow"><span>Symbolic Control Flow</span></a></li><li><a class="tocitem" href="#Inspection-Functions"><span>Inspection Functions</span></a></li></ul></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../external/">Working with External Symbolics Packages: SymPy, Mathematica, Oscar, and Beyond</a></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solver/">Solving Symbolic Equations</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Calculus</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../integration/">Symbolic Integrals</a></li><li><a class="tocitem" href="../ode/">Symbolic ODE Solving</a></li><li><a class="tocitem" href="../taylor/">Taylor Series</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Basics</a></li><li class="is-active"><a href>Variable and Equation Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variable and Equation Types</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/variables.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Variable-and-Equation-Types"><a class="docs-heading-anchor" href="#Variable-and-Equation-Types">Variable and Equation Types</a><a id="Variable-and-Equation-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-and-Equation-Types" title="Permalink"></a></h1><p>Symbolics IR mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the <code>Sym</code> type, which defines a symbolic variable. Registered (mathematical) functions on <code>Sym</code>s (or <code>iscall</code> objects) return an expression that <code>iscall</code>. For example, <code>op1 = x+y</code> is one symbolic object and <code>op2 = 2z</code> is another, and so <code>op1*op2</code> is another tree object. Then, at the top, an <code>Equation</code>, normally written as <code>op1 ~ op2</code>, defines the symbolic equality between two operations.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p><code>Sym</code>, <code>Term</code>, and <code>FnType</code> are from <a href="https://symbolicutils.juliasymbolics.org/api/">SymbolicUtils.jl</a>. Note that in Symbolics, we always use <code>Sym{Real}</code>, <code>Term{Real}</code>, and <code>FnType{Tuple{Any}, Real}</code>. To get the arguments of an <code>iscall</code> object, use <code>arguments(t::Term)</code>, and to get the operation, use <code>operation(t::Term)</code>. However, note that one should never dispatch on <code>Term</code> or test <code>isa Term</code>. Instead, one needs to use <code>SymbolicUtils.iscall</code> to check if <code>arguments</code> and <code>operation</code> is defined.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.@variables" href="#Symbolics.@variables"><code>Symbolics.@variables</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Define one or more unknown variables.</p><pre><code class="language-julia hljs">@variables t α σ(..) β[1:2]
@variables w(..) x(t) y z(t, α, x)

expr = β[1]* x + y^α + σ(3) * (z - t) - β[2] * w(t - 1)</code></pre><p><code>(..)</code> signifies that the value should be left uncalled.</p><p>Symbolics supports creating variables that denote an array of some size.</p><pre><code class="language-julia-repl hljs">julia&gt; @variables x[1:3]
1-element Vector{Symbolics.Arr{Num, 1}}:
 x[1:3]

julia&gt; @variables y[1:3, 1:6] # support for  tensors
1-element Vector{Symbolics.Arr{Num, 2}}:
 y[1:3,1:6]

julia&gt; @variables t z(t)[1:3] # also works for dependent variables
2-element Vector{Any}:
 t
  (z(t))[1:3]</code></pre><p>A symbol or expression that represents an array can be turned into an array of symbols or expressions using the <code>scalarize</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; Symbolics.scalarize(z)
3-element Vector{Num}:
 (z(t))[1]
 (z(t))[2]
 (z(t))[3]</code></pre><p>Note that <code>@variables</code> returns a vector of all the defined variables.</p><p><code>@variables</code> can also take runtime symbol values by the <code>$</code> interpolation operator, and in this case, <code>@variables</code> doesn&#39;t automatically assign the value, instead, it only returns a vector of symbolic variables. All the rest of the syntax also applies here.</p><pre><code class="language-julia-repl hljs">julia&gt; a, b, c = :runtime_symbol_value, :value_b, :value_c
(:runtime_symbol_value, :value_b, :value_c)

julia&gt; vars = @variables t $a $b(t) $c(t)[1:3]
4-element Vector{Any}:
      t
 runtime_symbol_value
   value_b(t)
       (value_c(t))[1:3]

julia&gt; (t, a, b, c)
(t, :runtime_symbol_value, :value_b, :value_c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/variable.jl#L431-L493">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.variable" href="#Symbolics.variable"><code>Symbolics.variable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variable(name::Symbol, idx::Integer...; T=Real)</code></pre><p>Create a variable with the given name along with subscripted indices with the <code>symtype=T</code>. When <code>T=FnType</code>, it creates a symbolic function.</p><pre><code class="language-julia-repl hljs">julia&gt; Symbolics.variable(:x, 4, 2, 0)
x₄ˏ₂ˏ₀

julia&gt; Symbolics.variable(:x, 4, 2, 0, T=Symbolics.FnType)
x₄ˏ₂ˏ₀⋆</code></pre><p>Also see <code>variables</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/variable.jl#L759-L774">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.variables" href="#Symbolics.variables"><code>Symbolics.variables</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">variables(name::Symbol, indices...)</code></pre><p>Create a multi-dimensional array of individual variables named with subscript notation. Use <code>@variables</code> instead to create symbolic array variables (as opposed to array of variables). See <code>variable</code> to create one variable with subscripts.</p><pre><code class="language-julia-repl hljs">julia&gt; Symbolics.variables(:x, 1:3, 3:6)
3×4 Matrix{Num}:
 x₁ˏ₃  x₁ˏ₄  x₁ˏ₅  x₁ˏ₆
 x₂ˏ₃  x₂ˏ₄  x₂ˏ₅  x₂ˏ₆
 x₃ˏ₃  x₃ˏ₄  x₃ˏ₅  x₃ˏ₆</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/variable.jl#L739-L754">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.Equation" href="#Symbolics.Equation"><code>Symbolics.Equation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Equation</code></pre><p>An equality relationship between two expressions.</p><p><strong>Fields</strong></p><ul><li><p><code>lhs</code>: The expression on the left-hand side of the equation.</p></li><li><p><code>rhs</code>: The expression on the right-hand side of the equation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/equations.jl#L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:~-Tuple{Num, Num}" href="#Base.:~-Tuple{Num, Num}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">~(lhs, rhs) -&gt; Any
</code></pre><p>Create an <a href="#Symbolics.Equation"><code>Equation</code></a> out of two <a href="@ref"><code>Num</code></a> instances, or an <code>Num</code> and a <code>Number</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; @variables x y;

julia&gt; @variables A[1:3, 1:3] B[1:3, 1:3];

julia&gt; x ~ y
x ~ y

julia&gt; x - y ~ 0
x - y ~ 0

julia&gt; A ~ B
(broadcast(~, A, B))[1:3,1:3]

julia&gt; A .~ 3x
(broadcast(~, A, 3x))[1:3,1:3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/equations.jl#L150">source</a></section></article><h2 id="A-note-about-functions-restricted-to-Numbers"><a class="docs-heading-anchor" href="#A-note-about-functions-restricted-to-Numbers">A note about functions restricted to <code>Number</code>s</a><a id="A-note-about-functions-restricted-to-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-about-functions-restricted-to-Numbers" title="Permalink"></a></h2><p><code>Sym</code> and <code>Term</code> objects are NOT subtypes of <code>Number</code>. Symbolics provides a simple wrapper type called <code>Num</code> which is a subtype of <code>Real</code>. <code>Num</code> wraps either a Sym or a Term or any other object, defines the same set of operations as symbolic expressions and forwards those to the values it wraps. You can use <code>Symbolics.value</code> function to unwrap a <code>Num</code>.</p><p>By default, the <code>@variables</code> macros return Num-wrapped objects to allow calling functions which are restricted to <code>Number</code> or <code>Real</code>.</p><pre><code class="language-julia hljs">using Symbolics
@variables t x y z(t);
Symbolics.operation(Symbolics.value(x + y))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">+ (generic function with 1060 methods)</code></pre><pre><code class="language-julia hljs">Symbolics.operation(Symbolics.value(z))</code></pre><p class="math-container">\[ \begin{equation}
z
\end{equation}
 \]</p><pre><code class="language-julia hljs">Symbolics.arguments(Symbolics.value(x + y))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element SymbolicUtils.SmallVec{Any, Vector{Any}}:
 y
 x</code></pre><p>Note that Julia converts irrationals — like <code>π</code> and <code>ℯ</code> — to <code>Float64</code> whenever they are involved in arithmetic with other numbers, including integers.  An expression like <code>2π</code> will be converted to a float immediately, so an expression like <code>2π * x</code> will leave the symbolic <code>x</code> multiplied by a <code>Float64</code>.  It may be preferable to have a symbolic representation of <code>π</code> also, which can be achieved with <code>Num(π)</code>.  For generic programming, it may be helpful to simply redefine the variable <code>π</code> to be of the same type as some other argument, as in</p><pre><code class="language-julia hljs">function f(x)
    let π=oftype(x, π)
        1 + (2//3 + 4π/5) * x
    end
end
f(t)</code></pre><p class="math-container">\[ \begin{equation}
1 + t \left( \frac{2}{3} + \frac{4}{5} \pi \right)
\end{equation}
 \]</p><p>This will work for any floating-point input, as well as symbolic input.</p><h2 id="Symbolic-Control-Flow"><a class="docs-heading-anchor" href="#Symbolic-Control-Flow">Symbolic Control Flow</a><a id="Symbolic-Control-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Control-Flow" title="Permalink"></a></h2><p>Control flow can be expressed in Symbolics.jl in the following way:</p><ul><li><code>ifelse(cond,x,y)</code>: this function allows to encode conditionals in the symbolic branches.</li></ul><h2 id="Inspection-Functions"><a class="docs-heading-anchor" href="#Inspection-Functions">Inspection Functions</a><a id="Inspection-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Inspection-Functions" title="Permalink"></a></h2><div class="admonition is-warning" id="Missing-docstring.-a72a5d5d885f9939"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-a72a5d5d885f9939" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.iscall</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning" id="Missing-docstring.-ca1e59e671597c67"><header class="admonition-header">Missing docstring.<a class="admonition-anchor" href="#Missing-docstring.-ca1e59e671597c67" title="Permalink"></a></header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.operation</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermInterface.arguments" href="#TermInterface.arguments"><code>TermInterface.arguments</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arguments(x, op::Function)</code></pre><p>Get the arguments of the symbolic expression <code>x</code> with respect to the operation or function <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/deabb733221d327e9361e98cf09eb008f63855f2/src/utils.jl#L488-L492">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/perturbation/">« Mixed Symbolic-Numeric Perturbation Theory</a><a class="docs-footer-nextpage" href="../expression_manipulation/">Expression Manipulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 31 July 2025 17:33">Thursday 31 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
