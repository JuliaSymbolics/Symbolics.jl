<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver · Symbolics.jl</title><meta name="title" content="Solver · Symbolics.jl"/><meta property="og:title" content="Solver · Symbolics.jl"/><meta property="twitter:title" content="Solver · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li><a class="tocitem" href="../../tutorials/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../taylor/">Taylor Series</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li class="is-active"><a class="tocitem" href>Solver</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/solver.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver"><a class="docs-heading-anchor" href="#Solver">Solver</a><a id="Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Solver" title="Permalink"></a></h1><p>The main symbolic solver for Symbolics.jl is <code>symbolic_solve</code>. Symbolic solving means that it only uses symbolic (algebraic) methods and outputs exact solutions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.symbolic_solve" href="#Symbolics.symbolic_solve"><code>Symbolics.symbolic_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_solve(expr, x; dropmultiplicity=true, warns=true)</code></pre><p><code>symbolic_solve</code> is a function which attempts to solve input equations/expressions symbolically using various methods.</p><p><strong>Arguments</strong></p><ul><li><p>expr: Could be a single univar expression in the form of a poly or multiple univar expressions or multiple multivar polys or a transcendental nonlinear function.</p></li><li><p>x: Could be a single variable or an array of variables which should be solved</p></li><li><p>dropmultiplicity (optional): Should the output be printed <code>n</code> times where <code>n</code> is the number of occurrence of the root? Say we have <code>(x+1)^2</code>, we then have 2 roots <code>x = -1</code>, by default the output is <code>[-1]</code>, If dropmultiplicity is inputted as false, then the output is <code>[-1, -1]</code>.</p></li><li><p>warns (optional): When invalid expressions or cases are inputted, should the solver warn you of such cases before returning nothing? if this is set to false, the solver returns nothing. By default, warns are set to true.</p></li></ul><p><strong>Supported input</strong></p><p>The base solver (<code>symbolic_solve</code>) has multiple solvers which chooses from depending on the the type of input (multiple/uni var and multiple/single expression) only after ensuring that the input is valid.</p><p>The expressions inputted can contain parameters, which are assumed to be transcendental. A parameter &quot;a&quot; is transcendental if there exists no polynomial P with rational coefficients such that P(a) = 0. Check the examples section.</p><p>Currently, <code>symbolic_solve</code> supports</p><ul><li>Linear and polynomial equations (with parameters)</li><li>Systems of linear and polynomials equations (without extra parameters, for now)</li><li>Equations with transcendental functions (with parameters)</li></ul><p><strong>Examples</strong></p><p><strong><code>solve_univar</code> (uses factoring and analytic solutions up to degree 4)</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The package <code>Nemo</code> is needed in order to use <code>solve_univar</code> as well as <code>solve_multipoly</code>, so executing <code>using Nemo</code> as you will see in the following examples is necessary; otherwise, the function will throw an error.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics, Nemo;

julia&gt; @variables x a b;

julia&gt; expr = expand((x + b)*(x^2 + 2x + 1)*(x^2 - a))
-a*b - a*x - 2a*b*x - 2a*(x^2) + b*(x^2) + x^3 - a*b*(x^2) - a*(x^3) + 2b*(x^3) + 2(x^4) + b*(x^4) + x^5

julia&gt; symbolic_solve(expr, x)
4-element Vector{Any}:
 -1
   -b
   (1//2)*√(4a)
   (-1//2)*√(4a)

julia&gt; symbolic_solve(expr, x, dropmultiplicity=false)
5-element Vector{Any}:
 -1
 -1
   -b
   (1//2)*√(4a)
   (-1//2)*√(4a)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(x^2 + a*x + 6, x)
2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (1//2)*(-a + √(-24 + a^2))
 (1//2)*(-a - √(-24 + a^2))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(x^7 - 1, x)
2-element Vector{Any}:
  roots_of((1//1) + x + x^2 + x^3 + x^4 + x^5 + x^6, x)
 1</code></pre><p><strong><code>solve_multivar</code> (uses Groebner basis and <code>solve_univar</code> to find roots)</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Similar to <code>solve_univar</code>, <code>Groebner</code> is needed for <code>solve_multivar</code> or to be fully functional.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Groebner

julia&gt; @variables x y z
3-element Vector{Num}:
 x
 y
 z

julia&gt; eqs = [x+y^2+z, z*x*y, z+3x+y]
3-element Vector{Num}:
 x + z + y^2
       x*y*z
  3x + y + z

julia&gt; symbolic_solve(eqs, [x,y,z])
3-element Vector{Any}:
 Dict{Num, Any}(z =&gt; 0, y =&gt; 1//3, x =&gt; -1//9)
 Dict{Num, Any}(z =&gt; 0, y =&gt; 0, x =&gt; 0)
 Dict{Num, Any}(z =&gt; -1, y =&gt; 1, x =&gt; 0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>Nemo</code> or <code>Groebner</code> are not imported when needed, the solver throws an error.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; @variables x y z;

julia&gt; symbolic_solve(x+1, x)
ERROR: &quot;Nemo is required. Execute `using Nemo` to enable this functionality.&quot;

julia&gt; symbolic_solve([x+1, y], [x, y])
ERROR: &quot;Groebner bases engine is required. Execute `using Groebner` to enable this functionality.&quot;</code></pre><p><strong><code>solve_multipoly</code> (uses GCD between the input polys)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve([x-1, x^3 - 1, x^2 - 1, (x-1)^20], x)
1-element Vector{BigInt}:
 1</code></pre><p><strong><code>ia_solve</code> (solving by isolation and attraction)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(2^(x+1) + 5^(x+3), x)
1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (-slog(2) - log(complex(-1)) + 3slog(5)) / (slog(2) - slog(5))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(log(x+1)+log(x-1), x)
2-element Vector{SymbolicUtils.BasicSymbolic{BigFloat}}:
 (1//2)*√(8.0)
 (-1//2)*√(8.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(a*x^b + c, x)
((-c)^(1 / b)) / (a^(1 / b))</code></pre><p><strong>Evaluating output (converting to floats)</strong></p><p>If you want to evaluate the exact expressions found by <code>symbolic_solve</code>, you can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; roots = symbolic_solve(2^(x+1) + 5^(x+3), x)
1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (-slog(2) - log(complex(-1)) + 3slog(5)) / (slog(2) - slog(5))

julia&gt; Symbolics.symbolic_to_float.(roots)
1-element Vector{Complex{BigFloat}}:
 -4.512941594732059759689023145584186058252768936052415430071569066192919491762214 + 3.428598090438030380369414618548038962770087500755160535832807433942464545729382im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/main.jl#L2-L144">source</a></section></article><p>One other symbolic solver is <code>symbolic_linear_solve</code> which is limited compared to  <code>symbolic_solve</code> as it only solves linear equations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.symbolic_linear_solve" href="#Symbolics.symbolic_linear_solve"><code>Symbolics.symbolic_linear_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_linear_solve(eq, var; simplify, check) -&gt; Any
</code></pre><p>Solve equation(s) <code>eqs</code> for a set of variables <code>vars</code>.</p><p>Assumes <code>length(eqs) == length(vars)</code></p><p>Currently only works if all equations are linear. <code>check</code> if the expr is linear w.r.t <code>vars</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @variables x y
2-element Vector{Num}:
 x
 y

julia&gt; Symbolics.symbolic_linear_solve(x + y ~ 0, x)
-y

julia&gt; Symbolics.symbolic_linear_solve([x + y ~ 0, x - y ~ 2], [x, y])
2-element Vector{Float64}:
  1.0
 -1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/linear_algebra.jl#L75">source</a></section></article><p><code>symbolic_solve</code> only supports symbolic, i.e. non-floating point computations, and thus prefers equations where the coefficients are integer, rational, or symbolic. Floating point coefficients are transformed into rational values and BigInt values are used internally with a potential performance loss, and thus it is recommended that this functionality is only used with floating point values if necessary. In contrast, <code>symbolic_linear_solve</code> directly handles floating point values using standard factorizations.</p><h3 id="More-technical-details-and-examples"><a class="docs-heading-anchor" href="#More-technical-details-and-examples">More technical details and examples</a><a id="More-technical-details-and-examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-technical-details-and-examples" title="Permalink"></a></h3><h4 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h4><p>The <code>symbolic_solve</code> function uses 4 hidden solvers in order to solve the user&#39;s input. Its base, <code>solve_univar</code>, uses analytic solutions up to polynomials of degree 4 and factoring as its method for solving univariate polynomials. The function&#39;s <code>solve_multipoly</code> uses GCD on the input polynomials then throws passes the result to <code>solve_univar</code>. The function&#39;s <code>solve_multivar</code> uses Groebner basis and a separating form in order to create linear equations in the input variables and a single high degree equation in the separating variable <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Each equation resulting from the basis is then passed to <code>solve_univar</code>. We can see that essentially, <code>solve_univar</code> is the building block of <code>symbolic_solve</code>. If the input is not a valid polynomial and can not be solved by the algorithm above, <code>symbolic_solve</code> passes it to <code>ia_solve</code>, which attempts solving by attraction and isolation <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. This only works when the input is a single expression and the user wants the answer in terms of a single variable. Say <code>log(x) - a == 0</code> gives us <code>[e^a]</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.solve_univar" href="#Symbolics.solve_univar"><code>Symbolics.solve_univar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_univar(expression, x; dropmultiplicity=true)</code></pre><p>This solver uses analytic solutions up to degree 4 to solve univariate polynomials. It first handles the special case of the expression being of operation <code>^</code>. E.g. <code>math (x+2)^{20}</code>. We solve this by removing the int <code>20</code>, then solving the poly <code>math x+2</code> on its own. If the parameter mult of the solver is set to true, we then repeat the found roots of <code>math x+2</code> twenty times before returning the results to the user.</p><p>Step 2 is filtering the expression after handling this special case, and then factoring it using <code>factor_use_nemo</code>. We then solve all the factors outputted using the analytic methods implemented in the function <code>get_roots</code> and its children.</p><p><strong>Arguments</strong></p><ul><li><p>expr: Single symbolics Num or SymbolicUtils.BasicSymbolic expression. This is equated to 0 and then solved. E.g. <code>expr = x+2</code>, we solve <code>x+2 = 0</code></p></li><li><p>x: Single symbolics variable</p></li><li><p>dropmultiplicity (optional): Print repeated roots or not?</p></li><li><p>strict (optional): Bool that enables/disables strict assert if input expression is a univariate polynomial or not. If strict=true and expression is not a polynomial, <code>solve_univar</code> throws an assertion error.</p></li></ul><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/main.jl#L256-L279">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Symbolics.solve_multivar</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.ia_solve" href="#Symbolics.ia_solve"><code>Symbolics.ia_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ia_solve(lhs, var; kwargs...)</code></pre><p>This function attempts to solve transcendental functions by first checking the &quot;smart&quot; number of occurrences in the input LHS. By smart here we mean that polynomials are counted as 1 occurrence. for example <code>x^2 + 2x</code> is 1 occurrence of x. So we abstract all occurrences of x&#39;s as polynomials. Say: <code>log(x+1) + x^2</code> is seen as <code>log(f(x)) + g(x)</code> so there are 2 occurrences of x. If there is only 1 occurrence of x in an input expression, isolate is called.</p><p>Isolate reverses all operations applied on the occurrence of x until we have <code>f(x) = some constant</code> then we can solve this using our polynomial solvers.</p><p>If more than 1 occurrence of x is found, <code>ia_solve</code> attempts to attract the occurrences of x in order to reduce these occurrences to 1. For example, <code>log(x+1) + log(x-1)</code> can be converted to <code>log(x^2 - 1)</code> which now could be isolated using Isolate.</p><p><code>attract(lhs, var)</code> currently uses 4 techniques for attraction.</p><ul><li>Log addition: <code>log(f(x)) + log(g(x)) =&gt; log(h(x))</code></li><li>Exponential simplification: <code>a*b^(f(x)) + c*d^(g(x)) =&gt; f(x) * log(b) - g(x) * log(d) + log(-a/c)</code>. And now this is actually 1 occurrence of x since <code>f(x)</code> and <code>g(x)</code> are just multiplied by constants not wrapped in some operation.</li><li>Trig simplification: this bruteforces multiple trig identities and doesn&#39;t detect them before hand.</li><li>Polynomialization: as a last resort, attract attempts to polynomialize the expression. Say <code>sin(x+2)^2 + sin(x+2) + 10</code> is converted to <code>X^2 + X + 10</code>, we then solve this using our polynomial solver, and afterwards, isolate <code>sin(x+2) = the roots found by solve for X^2 + X + 10</code></li></ul><p>After attraction, we check the number of occurrences again, and if its 1, we isolate, if not, we throw an error to tell the user that this is currently unsolvable by our covered techniques.</p><p><strong>Arguments</strong></p><ul><li>lhs: a Num/SymbolicUtils.BasicSymbolic</li><li>var: variable to solve for.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>warns = true</code>: Whether to emit warnings for unsolvable expressions.</li><li><code>complex_roots = true</code>: Whether to consider complex roots of <code>x ^ n ~ y</code>, where <code>n</code> is an integer.</li><li><code>periodic_roots = true</code>: If <code>true</code>, isolate <code>f(x) ~ y</code> as <code>x ~ finv(y) + n * period</code> where  <code>is_periodic(f) == true</code>, <code>finv = left_inverse(f)</code> and <code>period = fundamental_period(f)</code>. <code>n</code>  is a new anonymous symbolic variable.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; solve(a*x^b + c, x)
((-c)^(1 / b)) / (a^(1 / b))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; solve(2^(x+1) + 5^(x+3), x)
1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (-log(2) + 3log(5) - log(complex(-1))) / (log(2) - log(5))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; solve(log(x+1)+log(x-1), x)
2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (1//2)*RootFinding.ssqrt(8.0)
 (-1//2)*RootFinding.ssqrt(8.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; expr = sin(x+2)^2 + sin(x+2) + 10
10 + sin(2 + x) + sin(2 + x)^2

julia&gt; RootFinding.ia_solve(expr, x)
[ Info: var&quot;##230&quot; ϵ Ζ: e.g. 0, 1, 2...
[ Info: var&quot;##234&quot; ϵ Ζ: e.g. 0, 1, 2...
2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 -2 + π*2var&quot;##230&quot; + asin((1//2)*(-1 + RootFinding.ssqrt(-39)))
 -2 + π*2var&quot;##234&quot; + asin((1//2)*(-1 - RootFinding.ssqrt(-39)))</code></pre><p>All transcendental functions for which <code>left_inverse</code> is defined are supported. To enable <code>ia_solve</code> to handle custom transcendental functions, define an inverse or left inverse. If the function is periodic, <code>is_periodic</code> and <code>fundamental_period</code> must be defined. If the function imposes certain conditions on its input or output (for example, <code>log</code> requires that its input be positive) define <code>ia_conditions!</code>.</p><p>See also: <a href="../functions/#Symbolics.left_inverse"><code>left_inverse</code></a>, <a href="../functions/#Symbolics.inverse"><code>inverse</code></a>, <a href="#Symbolics.is_periodic"><code>is_periodic</code></a>, <a href="#Symbolics.fundamental_period"><code>fundamental_period</code></a>, <a href="#Symbolics.ia_conditions!"><code>ia_conditions!</code></a>.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/ia_main.jl#L198-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.ia_conditions!" href="#Symbolics.ia_conditions!"><code>Symbolics.ia_conditions!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ia_conditions!(f, lhs, rhs::Vector{Any}, conditions::Vector{Tuple})</code></pre><p>If <code>f</code> is a left-invertible function, <code>lhs</code> and <code>rhs[i]</code> are univariate functions and <code>f(lhs) ~ rhs[i]</code> for all <code>i in eachindex(rhss)</code>, push to <code>conditions</code> all the relevant conditions on <code>lhs</code> or <code>rhs[i]</code>. Each condition is of the form <code>(sym, op)</code> where <code>sym</code> is an expression involving <code>lhs</code> and/or <code>rhs[i]</code> and <code>op</code> is a binary relational operator. The condition <code>op(sym, 0)</code> is then required to be true for the equation <code>f(lhs) ~ rhs[i]</code> to be valid.</p><p>For example, if <code>f = log</code>, <code>lhs = x</code> and <code>rhss = [y, z]</code> then the condition <code>x &gt; 0</code> must be true. Thus, <code>(lhs, &gt;)</code> is pushed to <code>conditions</code>. Similarly, if <code>f = sqrt</code>, <code>rhs[i] &gt;= 0</code> must be true for all <code>i</code>, and so <code>(y, &gt;=)</code> and <code>(z, &gt;=)</code> will be appended to <code>conditions</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/ia_helpers.jl#L144-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.is_periodic" href="#Symbolics.is_periodic"><code>Symbolics.is_periodic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_periodic(f)</code></pre><p>Return <code>true</code> if <code>f</code> is a single-input single-output periodic function. Return <code>false</code> by default. If <code>is_periodic(f) == true</code>, then <code>fundamental_period(f)</code> must also be defined.</p><p>See also: <a href="#Symbolics.fundamental_period"><code>fundamental_period</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/ia_helpers.jl#L180-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.fundamental_period" href="#Symbolics.fundamental_period"><code>Symbolics.fundamental_period</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fundamental_period(f)</code></pre><p>Return the fundamental period of periodic function <code>f</code>. Must only be called if <code>is_periodic(f) == true</code>.</p><p>see also: <a href="#Symbolics.is_periodic"><code>is_periodic</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/ab3fcd618de5cd6e2681305141a44bf32501600a/src/solver/ia_helpers.jl#L197-L204">source</a></section></article><h4 id="Nice-examples"><a class="docs-heading-anchor" href="#Nice-examples">Nice examples</a><a id="Nice-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Nice-examples" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Symbolics, Nemo;
@variables x;
Symbolics.symbolic_solve(9^x + 3^x ~ 8, x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 slog(-(1//2) + (1//2)*√(33)) / slog(3)
 slog(-(1//2) - (1//2)*√(33)) / slog(3)</code></pre><pre><code class="language-julia hljs">@variables x y z;
Symbolics.symbolic_linear_solve(2//1*x + y - 2//1*z ~ 9//1*x, 1//1*x)</code></pre><p class="math-container">\[ \begin{equation}
\frac{1}{7} \left( y - 2 z \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">using Groebner;
@variables x y z;

eqs = [x^2 + y + z - 1, x + y^2 + z - 1, x + y + z^2 - 1]
Symbolics.symbolic_solve(eqs, [x,y,z])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Any}:
 Dict{Num, Any}(z =&gt; 1, y =&gt; 0, x =&gt; 0)
 Dict{Num, Any}(z =&gt; -1 + √(2), y =&gt; -1 + √(2), x =&gt; -1 + √(2))
 Dict{Num, Any}(z =&gt; -1 - √(2), y =&gt; -1 - √(2), x =&gt; -1 - √(2))
 Dict{Num, Any}(z =&gt; 0, y =&gt; 0, x =&gt; 1)
 Dict{Num, Any}(z =&gt; 0, y =&gt; 1, x =&gt; 0)</code></pre><h3 id="Feature-completeness"><a class="docs-heading-anchor" href="#Feature-completeness">Feature completeness</a><a id="Feature-completeness-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-completeness" title="Permalink"></a></h3><ul><li>[x] Linear and polynomial equations</li><li>[x] Systems of linear and polynomial equations</li><li>[x] Some transcendental functions</li><li>[x] Systems of linear equations with parameters (via <code>symbolic_linear_solve</code>)</li><li>[ ] Equations with radicals</li><li>[x] Systems of polynomial equations with parameters and positive dimensional systems</li><li>[ ] Inequalities</li></ul><h3 id="Expressions-we-can-not-solve-(but-aim-to)"><a class="docs-heading-anchor" href="#Expressions-we-can-not-solve-(but-aim-to)">Expressions we can not solve (but aim to)</a><a id="Expressions-we-can-not-solve-(but-aim-to)-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-we-can-not-solve-(but-aim-to)" title="Permalink"></a></h3><pre><code class="nohighlight hljs"># Mathematica

In[1]:= Reduce[x^2 - x - 6 &gt; 0, x]
Out[1]= x &lt; -2 || x &gt; 3

In[2]:= Reduce[x+a &gt; 0, x]
Out[2]= a \[Element] Reals &amp;&amp; x &gt; -a

In[3]:= Solve[x^(x)  + 3 == 0, x]
Out[3]= {{x -&gt; (I \[Pi] + Log[3])/ProductLog[I \[Pi] + Log[3]]}}</code></pre><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://www.sciencedirect.com/science/article/pii/S0747717189800070">R. W. Hamming, Coding and Information Theory, ScienceDirect, 1980</a>.</li><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://doi.org/10.1007/s002000050114">Rouillier, F. Solving Zero-Dimensional Systems Through the Rational Univariate Representation. AAECC 9, 433–461 (1999).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.sciencedirect.com/science/article/pii/S0747717189800070">R. W. Hamming, Coding and Information Theory, ScienceDirect, 1980</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../groebner/">« Groebner bases</a><a class="docs-footer-nextpage" href="../arrays/">Symbolic Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 17 December 2024 11:16">Tuesday 17 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
