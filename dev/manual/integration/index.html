<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Integrals · Symbolics.jl</title><meta name="title" content="Symbolic Integrals · Symbolics.jl"/><meta property="og:title" content="Symbolic Integrals · Symbolics.jl"/><meta property="twitter:title" content="Symbolic Integrals · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/integration/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/integration/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/integration/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li><a class="tocitem" href="../../tutorials/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../external/">Working with External Symbolics Packages: SymPy, Mathematica, Oscar, and Beyond</a></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solver/">Solving Symbolic Equations</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li><a class="tocitem" href="../constraint_satisfaction/">Constraint Satisfaction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox" checked/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Calculus</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li class="is-active"><a class="tocitem" href>Symbolic Integrals</a><ul class="internal"><li><a class="tocitem" href="#Defining-Symbolic-Integrals"><span>Defining Symbolic Integrals</span></a></li><li><a class="tocitem" href="#Solving-Symbolic-Integrals"><span>Solving Symbolic Integrals</span></a></li></ul></li><li><a class="tocitem" href="../ode/">Symbolic ODE Solving</a></li><li><a class="tocitem" href="../taylor/">Taylor Series</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li><li><a class="tocitem" href="../misc/">Miscellaneous API</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Calculus</a></li><li class="is-active"><a href>Symbolic Integrals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Integrals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/integration.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Integrals"><a class="docs-heading-anchor" href="#Symbolic-Integrals">Symbolic Integrals</a><a id="Symbolic-Integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Integrals" title="Permalink"></a></h1><p>Symbolics.jl provides a the <code>Integral</code> operator for defining integrals. These can be used with various functionalities in order to represent integro-differential equations and as a representation for symbolic solving of integrals.</p><h2 id="Defining-Symbolic-Integrals"><a class="docs-heading-anchor" href="#Defining-Symbolic-Integrals">Defining Symbolic Integrals</a><a id="Defining-Symbolic-Integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Symbolic-Integrals" title="Permalink"></a></h2><p>Note that integration domains are defined using  <a href="https://github.com/JuliaApproximation/DomainSets.jl">DomainSets.jl</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.Integral" href="#Symbolics.Integral"><code>Symbolics.Integral</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Integral(domain)</code></pre><p>Defines an Integral operator I(ex) which represents the integral of <code>I</code> of the expression <code>ex</code> over the <code>domain</code>. Note that the <code>domain</code> must be a  <code>Symbolics.VarDomainPairing</code> where the chosen variable is the variable being integrated over, i.e. <code>Integral(x in domain)</code> means that <code>I</code> is the integral operator with respect to <code>dx</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">I1 = Integral(x in ClosedInterval(1, 5))
I2 = Integral(x in ClosedInterval(1, 5))

@variables a b
I = Integral(x in ClosedInterval(a, b))
@test isequal(I(0), 0)
@test isequal(I(2), 2*(b -a))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/integral.jl#L2-L22">source</a></section></article><h2 id="Solving-Symbolic-Integrals"><a class="docs-heading-anchor" href="#Solving-Symbolic-Integrals">Solving Symbolic Integrals</a><a id="Solving-Symbolic-Integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Symbolic-Integrals" title="Permalink"></a></h2><p>Symbolics.jl currently has the following options for solving integrals symbolically:</p><table><tr><th style="text-align: right">Package</th><th style="text-align: right">Method</th><th style="text-align: right">Description</th><th style="text-align: right">Pros</th><th style="text-align: right">Cons</th></tr><tr><td style="text-align: right">SymbolicIntegration.jl</td><td style="text-align: right">Risch Algorithm</td><td style="text-align: right">Implements theoretical Risch algorithm for elementary functions</td><td style="text-align: right">Mathematically rigorous, returns exact symbolic results, handles rational functions and transcendental functions (exp, log, trig)</td><td style="text-align: right">Still in early development, unstable, limited to specific function classes, no support for algebraic functions</td></tr><tr><td style="text-align: right">SymbolicIntegration.jl</td><td style="text-align: right">Rule-Based Method</td><td style="text-align: right">Applies over 3,400 integration rules systematically</td><td style="text-align: right">Handles non-integer powers, supports multiple symbolic variables, more flexible than pure Risch</td><td style="text-align: right">Rule-dependent success, no theoretical completeness guarantee, limited by predefined rule set</td></tr><tr><td style="text-align: right">SymbolicNumericIntegration.jl</td><td style="text-align: right">Symbolic-Numeric Hybrid</td><td style="text-align: right">Uses numeric integrators with symbolic regression machine learning methods</td><td style="text-align: right">Can solve some hard integrals very fast and easily, works differently from pure symbolic methods</td><td style="text-align: right">Can be unreliable in easy cases, will give floats (0.5) instead of rational values (1//2), precision loss</td></tr><tr><td style="text-align: right">SymPy&#39;s Integrate</td><td style="text-align: right">Hybrid Methods</td><td style="text-align: right">Uses SymPy (through SymPy.jl) to integrate the expression</td><td style="text-align: right">Reasonably robust and tested solution, mature implementation</td><td style="text-align: right">Extremely slow, Python overhead</td></tr></table><h3 id="SymbolicIntegration.jl"><a class="docs-heading-anchor" href="#SymbolicIntegration.jl">SymbolicIntegration.jl</a><a id="SymbolicIntegration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicIntegration.jl" title="Permalink"></a></h3><p>SymbolicIntegration.jl provides pure symbolic integration using multiple algorithmic approaches. Unlike numerical methods, it returns exact symbolic results with rational coefficients (e.g., <code>1//2</code> instead of <code>0.5</code>). The package implements a flexible framework for symbolic integration that uses Julia&#39;s multiple dispatch to select appropriate algorithms for different types of integrands.</p><p>The package offers two main integration methods:</p><h4 id="Risch-Algorithm-Method"><a class="docs-heading-anchor" href="#Risch-Algorithm-Method">Risch Algorithm Method</a><a id="Risch-Algorithm-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Risch-Algorithm-Method" title="Permalink"></a></h4><p>The <code>RischMethod</code> implements the theoretical Risch algorithm for integrating:</p><ul><li>Polynomial functions</li><li>Rational functions  </li><li>Exponential functions</li><li>Logarithmic functions</li><li>Trigonometric functions</li><li>Combinations of the above</li></ul><p>This method is mathematically rigorous and provides guaranteed results when an elementary antiderivative exists. However, it is still under development and may not handle all cases robustly.</p><h4 id="Rule-Based-Method"><a class="docs-heading-anchor" href="#Rule-Based-Method">Rule-Based Method</a><a id="Rule-Based-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Based-Method" title="Permalink"></a></h4><p>The rule-based approach systematically applies over 3,400 integration rules to solve integrals:</p><ul><li>Handles non-integer powers and algebraic functions</li><li>Supports more complex integrations than pure Risch</li><li>Can handle multiple symbolic variables</li><li>More flexible but depends on the predefined rule set</li></ul><p>The package automatically tries the Risch algorithm first, then falls back to rule-based methods if needed.</p><p>For using SymbolicIntegration.jl, see <a href="https://github.com/JuliaSymbolics/SymbolicIntegration.jl">the SymbolicIntegration.jl repository</a>  for more details. Quick examples:</p><pre><code class="language-julia hljs">using Symbolics
using SymbolicIntegration

@variables x

# Basic integrations (automatic method selection)
integrate(x^2, x)           # Returns (1//3)*(x^3)
integrate(1/x, x)           # Returns log(x)
integrate(exp(x), x)        # Returns exp(x)
integrate(1/(x^2 + 1), x)   # Returns atan(x)

# Rational function with complex roots (typically uses Risch)
f = (x^3 + x^2 + x + 2)/(x^4 + 3*x^2 + 2)
integrate(f, x)  # Returns (1//2)*log(2 + x^2) + atan(x)

# Nested transcendental functions (uses Risch)
integrate(1/(x*log(x)), x)  # Returns log(log(x))

# Explicit Risch method selection
integrate(sin(x)*cos(x), x, RischMethod())

# Configurable Risch method
risch = RischMethod(use_algebraic_closure=true, catch_errors=false)
integrate(exp(x)/(1 + exp(x)), x, risch)

# Rule-based method for cases not handled by Risch
integrate(x^(1/2), x)       # Uses rule-based method for non-integer powers
integrate(sqrt(x + 1), x)   # Handles algebraic functions via rules</code></pre><h3 id="SymbolicNumericIntegration.jl"><a class="docs-heading-anchor" href="#SymbolicNumericIntegration.jl">SymbolicNumericIntegration.jl</a><a id="SymbolicNumericIntegration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SymbolicNumericIntegration.jl" title="Permalink"></a></h3><p>SymbolicNumericIntegration.jl is a package for solving symbolic integrals using numerical methods.  Specifically, it mixes numerical integration with machine learning symbolic regression in order to discover the basis for the integrals solution, for which it then finds the coefficients and uses differentiation to prove the correctness of the result. While this technique is unusual and new, <a href="https://arxiv.org/abs/2201.12468v2">see the paper for details</a>, it has the advantage of working very differently from the purely symbolic methods, and thus the problems which it finds hard can be entirely different from ones which the purely symbolic methods find hard. That is, while purely symbolic methods have difficulty depending on the complexity of the expression, this method has difficulty depending on the uniqueness of the numerical solution of the expression, and there are many complex expressions which have a very distinct solution behavior and thus can be easy to solve through this method.</p><p>One major downside to this method is that, because it works numerically, there can be precision loss in the coefficients. Thus the returned solution may have <code>0.5</code> instead of <code>1//2</code>. </p><p>For using SymbolicNumericIntegration.jl, see <a href="https://docs.sciml.ai/SymbolicNumericIntegration/stable/">the SymbolicNumericIntegration.jl documentation</a> for more details. A quick example is:</p><pre><code class="language-julia hljs">using Symbolics
using SymbolicNumericIntegration

@variables x a b

integrate(3x^3 + 2x - 5)
# (x^2 + (3 // 4) * (x^4) - (5 // 1) * x, 0, 0)

integrate(exp(a * x), x; symbolic = true)
# (exp(a * x) / a, 0, 0)

integrate(sin(a * x) * cos(b * x), x; symbolic = true, detailed = false)
# (-a * cos(a * x) * cos(b * x) - b * sin(a * x) * sin(b * x)) / (a^2 - (b^2))</code></pre><h3 id="SymPy"><a class="docs-heading-anchor" href="#SymPy">SymPy</a><a id="SymPy-1"></a><a class="docs-heading-anchor-permalink" href="#SymPy" title="Permalink"></a></h3><p>The function <code>sympy_integrate</code> allows one to call  <a href="https://docs.sympy.org/latest/modules/integrals/integrals.html">SymPy&#39;s integration functionality</a>. While it&#39;s generally slow, if you leave your computer on for long enough it can solve some difficult expressions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.sympy_integrate" href="#Symbolics.sympy_integrate"><code>Symbolics.sympy_integrate</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sympy_integrate(expr, var)</code></pre><p>Computes indefinite integral of expr w.r.t. var using SymPy.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: Symbolics expression.</li><li><code>var</code>: Symbolics variable.</li></ul><p><strong>Returns</strong></p><p>Symbolics integral.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@variables x
expr = x^2
result = sympy_integrate(expr, x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/Symbolics.jl#L310-L324">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../derivatives/">« Derivatives and Differentials</a><a class="docs-footer-nextpage" href="../ode/">Symbolic ODE Solving »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 14 October 2025 09:11">Tuesday 14 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
