<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic ODE Solving · Symbolics.jl</title><meta name="title" content="Symbolic ODE Solving · Symbolics.jl"/><meta property="og:title" content="Symbolic ODE Solving · Symbolics.jl"/><meta property="twitter:title" content="Symbolic ODE Solving · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/ode/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/ode/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/ode/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li><a class="tocitem" href="../../tutorials/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../external/">Working with External Symbolics Packages: SymPy, Mathematica, Oscar, and Beyond</a></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solver/">Solving Symbolic Equations</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li><a class="tocitem" href="../constraint_satisfaction/">Constraint Satisfaction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox" checked/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Calculus</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../integration/">Symbolic Integrals</a></li><li class="is-active"><a class="tocitem" href>Symbolic ODE Solving</a><ul class="internal"><li><a class="tocitem" href="#Merging-Symbolic-ODEs-with-Numerical-Methods:-ModelingToolkit.jl"><span>Merging Symbolic ODEs with Numerical Methods: ModelingToolkit.jl</span></a></li><li><a class="tocitem" href="#Symbolically-Solving-ODEs"><span>Symbolically Solving ODEs</span></a></li></ul></li><li><a class="tocitem" href="../taylor/">Taylor Series</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li><li><a class="tocitem" href="../misc/">Miscellaneous API</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Calculus</a></li><li class="is-active"><a href>Symbolic ODE Solving</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic ODE Solving</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/ode.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-ODE-Solving"><a class="docs-heading-anchor" href="#Symbolic-ODE-Solving">Symbolic ODE Solving</a><a id="Symbolic-ODE-Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-ODE-Solving" title="Permalink"></a></h1><p>While not all ODEs have an analytical solution, symbolic ODE solving is provided by Symbolics.jl for  subsets of cases for which known analytical solutions can be obtained. These expressions can then be merged with other techniques in order to accelerate code or gain a deeper understanding of real-world systems.</p><h2 id="Merging-Symbolic-ODEs-with-Numerical-Methods:-ModelingToolkit.jl"><a class="docs-heading-anchor" href="#Merging-Symbolic-ODEs-with-Numerical-Methods:-ModelingToolkit.jl">Merging Symbolic ODEs with Numerical Methods: ModelingToolkit.jl</a><a id="Merging-Symbolic-ODEs-with-Numerical-Methods:-ModelingToolkit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Merging-Symbolic-ODEs-with-Numerical-Methods:-ModelingToolkit.jl" title="Permalink"></a></h2><p>If you are looking to merge Symbolics.jl manipulations with numerical solvers such as <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a>, then we highly recommend checking out the <a href="https://docs.sciml.ai/ModelingToolkit/dev/">ModelingToolkit.jl</a> system. It represents systems of differentible-algebraic equations (DAEs, and extension to ODEs) for which a sophisticated symbolic analysis pipeline is used to generate highly efficient code. This <code>mtkcompile</code> pipeline makes use of all tricks from Symbolics.jl and many that are more specific to numerical code generation, such as Pantelides index reduction and tearing of nonlinear systems, and it will analytically solve subsets of the ODE system as finds possible. Thus if you are attempting to use Symbolics to pre-solve some parts of an ODE analytically, we recommend allowing ModelingToolkit.jl to do this optimization.</p><p>Note that if ModelingToolkit is able to analytically solve the equation, it will give an <code>ODEProblem</code> where <code>prob.u0 === nothing</code>, and then running <code>solve</code> on the <code>ODEProblem</code> will give a numerical <code>ODESolution</code> object that on-demand uses the analytical solution to generate any plots or other artifacts. The analytical solution can be investigated symbolically using <code>observed(sys)</code>.</p><h2 id="Symbolically-Solving-ODEs"><a class="docs-heading-anchor" href="#Symbolically-Solving-ODEs">Symbolically Solving ODEs</a><a id="Symbolically-Solving-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolically-Solving-ODEs" title="Permalink"></a></h2><div class="admonition is-info" id="Note-71d8004d5b719c12"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-71d8004d5b719c12" title="Permalink"></a></header><div class="admonition-body"><p>This area is currently under heavy development. More solvers will be available in the near future.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.SymbolicLinearODE" href="#Symbolics.SymbolicLinearODE"><code>Symbolics.SymbolicLinearODE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Represents a linear ordinary differential equation of the form:</p><p>dⁿx/dtⁿ + pₙ(t)(dⁿ⁻¹x/dtⁿ⁻¹) + ... + p₂(t)(dx/dt) + p₁(t)x = q(t)</p><p><strong>Fields</strong></p><ul><li><code>x</code>: dependent variable</li><li><code>t</code>: independent variable</li><li><code>p</code>: coefficient functions of <code>t</code> ordered in increasing order (p₁, p₂, ...)</li><li><code>q</code>: right hand side function of <code>t</code>, without any <code>x</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; @variables x, t
2-element Vector{Num}:
 x
 t

julia&gt; eq = SymbolicLinearODE(x, t, [1, 2, 3], 3exp(4t))
(Dt^3)x + (3)(Dt^2)x + (2)(Dt^1)x + (1)(Dt^0)x ~ 3exp(4t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/diffeqs/diffeqs.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.symbolic_solve_ode" href="#Symbolics.symbolic_solve_ode"><code>Symbolics.symbolic_solve_ode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_solve_ode(eq::SymbolicLinearODE)</code></pre><p>Symbolically solve a linear ordinary differential equation</p><p><strong>Arguments</strong></p><ul><li>eq: a <code>SymbolicLinearODE</code> to solve</li></ul><p><strong>Returns</strong></p><p>Symbolic solution to the ODE</p><p><strong>Supported Methods</strong></p><ul><li>first-order integrating factor</li><li>constant coefficient homogeneous solutions (can handle repeated and complex characteristic roots)</li><li>exponential and resonant response formula particular solutions (for any linear combination of <code>exp</code>, <code>sin</code>, <code>cos</code>, or <code>exp</code> times <code>sin</code> or <code>cos</code> (e.g. <code>e^2t * cos(-t) + e^-3t + sin(5t))</code>)</li><li>method of undetermined coefficients particular solutions</li><li>linear combinations of above particular solutions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics; import Nemo, SymPy

julia&gt; @variables x, t
2-element Vector{Num}:
 x
 t

# Integrating Factor (note that SymPy is required for integration)
julia&gt; symbolic_solve_ode(SymbolicLinearODE(x, t, [5/t], 7t))
(C₁ + t^7) / (t^5)

# Constant Coefficients and RRF (note that Nemo is required to find characteristic roots)
julia&gt; symbolic_solve_ode(SymbolicLinearODE(x, t, [9, -6], 4exp(3t)))
C₁*exp(3t) + C₂*t*exp(3t) + (2//1)*(t^2)*exp(3t)

julia&gt; symbolic_solve_ode(SymbolicLinearODE(x, t, [6, 5], 2exp(-t)*cos(t)))
C₁*exp(-2t) + C₂*exp(-3t) + (1//5)*cos(t)*exp(-t) + (3//5)*exp(-t)*sin(t)

# Method of Undetermined Coefficients
julia&gt; symbolic_solve_ode(SymbolicLinearODE(x, t, [-3, 2], 2t - 5))
(11//9) - (2//3)*t + C₁*exp(t) + C₂*exp(-3t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/diffeqs/diffeqs.jl#L124-L166">source</a></section><section><div><pre><code class="language-julia hljs">symbolic_solve_ode(expr::Equation, x, t)</code></pre><p>Symbolically solve an ODE</p><p><strong>Arguments</strong></p><ul><li>expr: a symbolic ODE</li><li>x: dependent variable</li><li>t: independent variable</li></ul><p><strong>Supported Methods</strong></p><ul><li>all methods of solving linear ODEs mentioned for <code>symbolic_solve_ode(eq::SymbolicLinearODE)</code></li><li>Clairaut&#39;s equation</li><li>Bernoulli equations</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics; import Nemo

julia&gt; @variables x, t
2-element Vector{Num}:
 x
 t

julia&gt; Dt = Differential(t)
Differential(t)

# SymbolicLinearODE (via constant coefficients and RRF)
julia&gt; symbolic_solve_ode(9t*x - 6*Dt(x) ~ 4exp(3t), x, t)
C₁*exp(3t) + C₂*t*exp(3t) + (2//1)*(t^2)*exp(3t)

# Clairaut&#39;s equation
julia&gt; symbolic_solve_ode(x ~ Dt(x)*t - ((Dt(x))^3), x, t)
C₁*t - (C₁^3)

# Bernoulli equations
julia&gt; symbolic_solve_ode(Dt(x) + (4//t)*x ~ t^3 * x^2, x, t)
1 / (C₁*(t^4) - (t^4)*log(t))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/diffeqs/diffeqs.jl#L184-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.solve_symbolic_IVP" href="#Symbolics.solve_symbolic_IVP"><code>Symbolics.solve_symbolic_IVP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_symbolic_IVP(eq::SymbolicLinearODE, initial_conditions::Vector{&lt;:Number})</code></pre><p>Solve an initial value problem for a linear ODE with given initial conditions.</p><p><strong>Arguments</strong></p><ul><li><code>eq</code>: A <code>SymbolicLinearODE</code> to solve</li><li><code>initial_conditions</code>: Vector of initial conditions for x(0), x&#39;(0), x&#39;&#39;(0), etc.</li></ul><p><strong>Returns</strong></p><p>Symbolic solution satisfying the initial conditions</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics
julia&gt; @variables x, t
2-element Vector{Num}:
 x
 t

julia&gt; eq = SymbolicLinearODE(x, t, [-3, 2], 0)  # d²x/dt² + 2dx/dt - 3x = 0
julia&gt; solve_symbolic_IVP(eq, [1, -1])  # x(0) = 1, x&#39;(0) = -1
(1//2)*exp(-3t) + (1//2)*exp(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/diffeqs/diffeqs.jl#L562-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.solve_linear_ode_system" href="#Symbolics.solve_linear_ode_system"><code>Symbolics.solve_linear_ode_system</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_linear_ode_system(A::Matrix{&lt;:Number}, x0::Vector{&lt;:Number}, t::Num)</code></pre><p>Solve linear continuous dynamical system of differential equations of the form Ax = x&#39; with initial condition x0</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix of coefficients</li><li><code>x0</code>: initial conditions vector</li><li><code>t</code>: independent variable</li></ul><p><strong>Returns</strong></p><p>vector of symbolic solutions</p><p><strong>Examples</strong></p><p>!!! note uses method <code>symbolic_solve</code>, so packages <code>Nemo</code> and <code>Groebner</code> are often required</p><pre><code class="language-julia-repl hljs">julia&gt; @variables t
1-element Vector{Num}:
 t

julia&gt; solve_linear_ode_system([1 0; 0 -1], [1, -1], t) # requires Nemo
2-element Vector{Num}:
   exp(t)
 -exp(-t)

julia&gt; solve_linear_ode_system([-3 4; -2 3], [7, 2], t) # requires Groebner
2-element Vector{Num}:
 (10//1)*exp(-t) - (3//1)*exp(t)
  (5//1)*exp(-t) - (3//1)*exp(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/diffeqs/systems.jl#L8-L37">source</a></section></article><h3 id="SymPy"><a class="docs-heading-anchor" href="#SymPy">SymPy</a><a id="SymPy-1"></a><a class="docs-heading-anchor-permalink" href="#SymPy" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.sympy_ode_solve" href="#Symbolics.sympy_ode_solve"><code>Symbolics.sympy_ode_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sympy_ode_solve(expr, func, var)</code></pre><p>Solves ODE expr = 0 for function func w.r.t. var using SymPy.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: Symbolics expression representing ODE (set to 0).</li><li><code>func</code>: Symbolics function (e.g., f(x)).</li><li><code>var</code>: Independent Symbolics variable.</li></ul><p><strong>Returns</strong></p><p>Symbolics solution(s).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@variables x
@syms f(x)
expr = Symbolics.Derivative(f, x) - 2*f
sol = sympy_ode_solve(expr, f, x)  # Returns C1*exp(2*x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/Symbolics.jl#L361-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.sympy_pythoncall_ode_solve" href="#Symbolics.sympy_pythoncall_ode_solve"><code>Symbolics.sympy_pythoncall_ode_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sympy_pythoncall_ode_solve(expr, func, var)</code></pre><p>Solves ordinary differential equations using SymPyPythonCall.</p><p><strong>Arguments</strong></p><ul><li><code>expr</code>: Symbolics expression representing the ODE.</li><li><code>func</code>: Function to solve for.</li><li><code>var</code>: Independent variable.</li></ul><p><strong>Returns</strong></p><p>Symbolics solution(s).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@variables x
@syms f(x)
expr = Symbolics.Derivative(f, x) - 2*f
sol = sympy_pythoncall_ode_solve(expr, f, x)  # Returns C1*exp(2*x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/919390a5609d3a7319cc8e6f5357742fa5d0fda4/src/Symbolics.jl#L501-L517">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integration/">« Symbolic Integrals</a><a class="docs-footer-nextpage" href="../taylor/">Taylor Series »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 14 October 2025 09:11">Tuesday 14 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
