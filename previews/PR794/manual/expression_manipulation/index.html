<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Expression Manipulation · Symbolics.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li class="is-active"><a class="tocitem" href>Expression Manipulation</a><ul class="internal"><li><a class="tocitem" href="#Functionality-Inherited-From-SymbolicUtils.jl"><span>Functionality Inherited From SymbolicUtils.jl</span></a></li><li><a class="tocitem" href="#Additional-Manipulation-Functions"><span>Additional Manipulation Functions</span></a></li></ul></li><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li><a class="tocitem" href="../arrays/">Symbolic arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Expression Manipulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Expression Manipulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/expression_manipulation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Expression-Manipulation"><a class="docs-heading-anchor" href="#Expression-Manipulation">Expression Manipulation</a><a id="Expression-Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Manipulation" title="Permalink"></a></h1><p>Symbolics.jl provides functionality for easily manipulating expressions. Most of the functionality comes by the expression objects obeying the standard mathematical semantics. For example, if one has <code>A</code> a matrix of symbolic expressions wrapped in <code>Num</code>, then <code>A^2</code> calculates the expressions for the squared matrix.  It is thus encouraged to use standard Julia for performing many of the manipulation on the IR. For example, calculating the sparse form of the matrix via <code>sparse(A)</code> is valid, legible, and easily understandable to all Julia programmers.</p><h2 id="Functionality-Inherited-From-SymbolicUtils.jl"><a class="docs-heading-anchor" href="#Functionality-Inherited-From-SymbolicUtils.jl">Functionality Inherited From SymbolicUtils.jl</a><a id="Functionality-Inherited-From-SymbolicUtils.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Functionality-Inherited-From-SymbolicUtils.jl" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicUtils.substitute" href="#SymbolicUtils.substitute"><code>SymbolicUtils.substitute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substitute(expr, s)</code></pre><p>Performs the substitution on <code>expr</code> according to rule(s) <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables t x y z(t)
4-element Vector{Num}:
    t
    x
    y
 z(t)
julia&gt; ex = x + y + sin(z)
(x + y) + sin(z(t))
julia&gt; substitute(ex, Dict([x =&gt; z, sin(z) =&gt; z^2]))
(z(t) + y) + (z(t) ^ 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/Symbolics.jl#L49-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicUtils.simplify" href="#SymbolicUtils.simplify"><code>SymbolicUtils.simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplify(x; expand=false,
            threaded=false,
            thread_subtree_cutoff=100,
            rewriter=nothing)</code></pre><p>Simplify an expression (<code>x</code>) by applying <code>rewriter</code> until there are no changes. <code>expand=true</code> applies <a href="/api/#expand"><code>expand</code></a> in the beginning of each fixpoint iteration.</p><p>By default, simplify will assume denominators are not zero and allow cancellation in fractions. Pass <code>simplify_fractions=false</code> to prevent this.</p></div></section></article><p>Documentation for <code>rewriter</code> can be found <a href="https://symbolicutils.juliasymbolics.org/rewrite/">here</a>, using the <code>@rule</code> macro or the <code>@acrule</code> macro from SymbolicUtils.jl.</p><h2 id="Additional-Manipulation-Functions"><a class="docs-heading-anchor" href="#Additional-Manipulation-Functions">Additional Manipulation Functions</a><a id="Additional-Manipulation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Manipulation-Functions" title="Permalink"></a></h2><p>Other additional manipulation functions are given below.</p><article class="docstring"><header><a class="docstring-binding" id="Symbolics.get_variables" href="#Symbolics.get_variables"><code>Symbolics.get_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_variables(O) -&gt; Vector{BasicSymbolic}</code></pre><p>Returns the variables in the expression. Note that the returned variables are not wrapped in the <code>Num</code> type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables t x y z(t)
4-element Vector{Num}:
    t
    x
    y
 z(t)

julia&gt; ex = x + y + sin(z)
(x + y) + sin(z(t))

julia&gt; Symbolics.get_variables(ex)
3-element Vector{Any}:
 x
 y
 z(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/utils.jl#L22-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.tosymbol" href="#Symbolics.tosymbol"><code>Symbolics.tosymbol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tosymbol(x::Union{Num,Symbolic}; states=nothing, escape=true) -&gt; Symbol</code></pre><p>Convert <code>x</code> to a symbol. <code>states</code> are the states of a system, and <code>escape</code> means if the target has escapes like <code>val&quot;y(t)&quot;</code>. If <code>escape</code> is false, then it will only output <code>y</code> instead of <code>y(t)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables t z(t)
2-element Vector{Num}:
    t
 z(t)

julia&gt; Symbolics.tosymbol(z)
Symbol(&quot;z(t)&quot;)

julia&gt; Symbolics.tosymbol(z; escape=false)
:z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/utils.jl#L135-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.diff2term" href="#Symbolics.diff2term"><code>Symbolics.diff2term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diff2term(x) -&gt; Symbolic</code></pre><p>Convert a differential variable to a <code>Term</code>. Note that it only takes a <code>Term</code> not a <code>Num</code>.</p><pre><code class="language-julia hljs">julia&gt; @variables x t u(x, t) z(t)[1:2]; Dt = Differential(t); Dx = Differential(x);

julia&gt; Symbolics.diff2term(Symbolics.value(Dx(Dt(u))))
uˍtx(x, t)

julia&gt; Symbolics.diff2term(Symbolics.value(Dt(z[1])))
var&quot;z(t)[1]ˍt&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/utils.jl#L85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.solve_for" href="#Symbolics.solve_for"><code>Symbolics.solve_for</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve_for(eq, var; simplify, check) -&gt; Any
</code></pre><p>Solve equation(s) <code>eqs</code> for a set of variables <code>vars</code>.</p><p>Assumes <code>length(eqs) == length(vars)</code></p><p>Currently only works if all equations are linear. <code>check</code> if the expr is linear w.r.t <code>vars</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables x y
2-element Vector{Num}:
 x
 y

julia&gt; Symbolics.solve_for(x + y ~ 0, x)
-y

julia&gt; Symbolics.solve_for([x + y ~ 0, x - y ~ 2], [x, y])
2-element Vector{Float64}:
  1.0
 -1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/linear_algebra.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.degree" href="#Symbolics.degree"><code>Symbolics.degree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">degree(p, sym=nothing)</code></pre><p>Extract the degree of <code>p</code> with respect to <code>sym</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables x;

julia&gt; Symbolics.degree(x^0)
0

julia&gt; Symbolics.degree(x)
1

julia&gt; Symbolics.degree(x^2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/utils.jl#L232-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.coeff" href="#Symbolics.coeff"><code>Symbolics.coeff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coeff(p, sym=nothing)</code></pre><p>Extract the coefficient of <code>p</code> with respect to <code>sym</code>. Note that <code>p</code> might need to be expanded and/or simplified with <code>expand</code> and/or <code>simplify</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables a x y;

julia&gt; Symbolics.coeff(2a, x)
0

julia&gt; Symbolics.coeff(3x + 2y, y)
2

julia&gt; Symbolics.coeff(x^2 + y, x^2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/117ee6981fb52d1b5d4365bf315ac59012e2eb6c/src/utils.jl#L285-L305">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../variables/">« Variable and Equation Types</a><a class="docs-footer-nextpage" href="../derivatives/">Derivatives and Differentials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 March 2023 23:32">Friday 17 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
