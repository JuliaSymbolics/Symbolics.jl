<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl</title><meta name="title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta property="og:title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta property="twitter:title" content="Mixed Symbolic-Numeric Perturbation Theory · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/tutorials/perturbation/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/tutorials/perturbation/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/tutorials/perturbation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li class="is-active"><a class="tocitem" href>Mixed Symbolic-Numeric Perturbation Theory</a><ul class="internal"><li><a class="tocitem" href="#Solving-the-quintic-equation"><span>Solving the quintic equation</span></a></li><li><a class="tocitem" href="#Solving-Kepler&#39;s-Equation"><span>Solving Kepler&#39;s Equation</span></a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../../manual/expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../../manual/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../manual/external/">Working with External Symbolics Packages: SymPy, Mathematica, Oscar, and Beyond</a></li><li><a class="tocitem" href="../../manual/arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../../manual/build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../../manual/functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../../manual/parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../../manual/io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../../manual/types/">Supported types and dispatch in Symbolics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/solver/">Solving Symbolic Equations</a></li><li><a class="tocitem" href="../../manual/groebner/">Groebner bases</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Calculus</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../../manual/integration/">Symbolic Integrals</a></li><li><a class="tocitem" href="../../manual/ode/">Symbolic ODE Solving</a></li><li><a class="tocitem" href="../../manual/taylor/">Taylor Series</a></li><li><a class="tocitem" href="../../manual/sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../../manual/limits/">Symbolic Limits</a></li></ul></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Mixed Symbolic-Numeric Perturbation Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/tutorials/perturbation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="perturb_alg"><a class="docs-heading-anchor" href="#perturb_alg">Mixed Symbolic-Numeric Perturbation Theory</a><a id="perturb_alg-1"></a><a class="docs-heading-anchor-permalink" href="#perturb_alg" title="Permalink"></a></h1><p><a href="https://github.com/JuliaSymbolics/Symbolics.jl"><strong>Symbolics.jl</strong></a> is a fast and modern Computer Algebra System (CAS) written in Julia. It is an integral part of the <a href="https://sciml.ai/">SciML</a> ecosystem of differential equation solvers and scientific machine learning packages. While <strong>Symbolics.jl</strong> is primarily designed for modern scientific computing (e.g. automatic differentiation and machine learning), it is also a powerful CAS that can be used for <em>classic</em> scientific computing. One such application is using <em>perturbation theory</em> to solve algebraic and differential equations.</p><p>Perturbation methods are a collection of techniques to solve hard problems that generally don&#39;t have a closed solution, but depend on a tunable parameter and have closed or easy solutions for some values of this parameter. The main idea is to assume a solution that is a power series in the tunable parameter (say <span>$ϵ$</span>), such that <span>$ϵ = 0$</span> corresponds to an easy solution, and then solve iteratively for higher-order corrections.</p><p>The hallmark of perturbation theory is the generation of long and convoluted intermediate equations by this process. These are subjected to algorithmic and mechanical manipulations, which makes perturbation methods an excellent fit for a CAS. In fact, CAS software have been used for perturbation calculations since the early 1970s.</p><p>This tutorial shows how to mix symbolic manipulations and numerical methods to solve algebraic equations with perturbation theory. <a href="https://docs.sciml.ai/ModelingToolkit/stable/examples/perturbation/">Another tutorial applies it to differential equations</a>.</p><h2 id="Solving-the-quintic-equation"><a class="docs-heading-anchor" href="#Solving-the-quintic-equation">Solving the quintic equation</a><a id="Solving-the-quintic-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-quintic-equation" title="Permalink"></a></h2><p>The “hello world!” analog of perturbation problems is to find a real solution <span>$x$</span> to the quintic (fifth-order) equation</p><pre><code class="language-julia hljs">using Symbolics
@variables x
quintic = x^5 + x ~ 1</code></pre><p class="math-container">\[ \begin{equation}
x + x^{5} = 1
\end{equation}
 \]</p><p>According to Abel&#39;s theorem, a general quintic equation does not have a closed form solution. But we can easily solve it numerically using Newton&#39;s method (here implemented for simplicity, and not performance):</p><pre><code class="language-julia hljs">function solve_newton(eq, x, x₀; abstol=1e-8, maxiters=50)
    # symbolic expressions for f(x) and f′(x)
    f = eq.lhs - eq.rhs # want to find root of f(x)
    f′ = Symbolics.derivative(f, x)

    xₙ = x₀ # numerical value of the initial guess
    for i = 1:maxiters
        # calculate new guess by numerically evaluating symbolic expression at previous guess
        xₙ₊₁ = substitute(x - f / f′, x =&gt; xₙ)
        if abs(xₙ₊₁ - xₙ) &lt; abstol
            return xₙ₊₁ # converged
        else
            xₙ = xₙ₊₁
        end
    end
    error(&quot;Newton&#39;s method failed to converge&quot;)
end

x_newton = solve_newton(quintic, x, 1.0)
println(&quot;Newton&#39;s method solution: x = &quot;, x_newton)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Newton&#39;s method solution: x = 0.7548776662466927</code></pre><p>To solve the same problem with perturbation theory, we must introduce an expansion variable <span>$ϵ$</span> in the equation:</p><pre><code class="language-julia hljs">@variables ϵ # expansion variable
quintic = x^5 + ϵ*x ~ 1</code></pre><p class="math-container">\[ \begin{equation}
x \epsilon + x^{5} = 1
\end{equation}
 \]</p><p>If <span>$ϵ = 1$</span>, we get our original problem. With <span>$ϵ = 0$</span>, the problem transforms to the easy quintic equation <span>$x^5 = 1$</span> with the trivial real solution <span>$x = 1$</span> (and four complex solutions which we ignore). Next, expand <span>$x$</span> as a power series in <span>$ϵ$</span>:</p><pre><code class="language-julia hljs">x_coeffs, = @variables a[0:7] # create Taylor series coefficients
x_taylor = series(x_coeffs, ϵ) # expand x in a power series in ϵ</code></pre><p class="math-container">\[ \begin{equation}
a_{0} + a_{1} \epsilon + \epsilon^{2} a_{2} + \epsilon^{3} a_{3} + \epsilon^{4} a_{4} + \epsilon^{5} a_{5} + \epsilon^{6} a_{6} + \epsilon^{7} a_{7}
\end{equation}
 \]</p><p>Then insert this into the quintic equation and expand it, too, to the same order:</p><pre><code class="language-julia hljs">quintic_taylor = substitute(quintic, x =&gt; x_taylor)
quintic_taylor = taylor(quintic_taylor, ϵ, 0:7)</code></pre><p class="math-container">\[ \begin{equation}
\left( a_{0} \right)^{5} + \left( a_{0} + 5 \left( a_{0} \right)^{4} a_{1} \right) \epsilon + \frac{1}{2} \epsilon^{2} \left( 2 a_{1} + 10 \left( a_{0} \right)^{4} a_{2} + 20 \left( a_{1} \right)^{2} \left( a_{0} \right)^{3} \right) + \frac{1}{6} \epsilon^{3} \left( 6 a_{2} + 30 \left( a_{0} \right)^{4} a_{3} + 120 \left( a_{0} \right)^{3} a_{1} a_{2} + 60 \left( a_{1} \right)^{3} \left( a_{0} \right)^{2} \right) + \frac{1}{24} \epsilon^{4} \left( 24 a_{3} + 120 \left( a_{0} \right)^{4} a_{4} + 480 \left( a_{0} \right)^{3} a_{1} a_{3} + 240 \left( a_{2} \right)^{2} \left( a_{0} \right)^{3} + 720 \left( a_{1} \right)^{2} \left( a_{0} \right)^{2} a_{2} + 120 \left( a_{1} \right)^{4} a_{0} \right) + \frac{1}{120} \epsilon^{5} \left( 120 a_{4} + 600 \left( a_{0} \right)^{4} a_{5} + 2400 \left( a_{0} \right)^{3} a_{1} a_{4} + 2400 \left( a_{0} \right)^{3} a_{2} a_{3} + 3600 \left( a_{1} \right)^{2} \left( a_{0} \right)^{2} a_{3} + 3600 \left( a_{2} \right)^{2} \left( a_{0} \right)^{2} a_{1} + 2400 \left( a_{1} \right)^{3} a_{0} a_{2} + 120 \left( a_{1} \right)^{5} \right) + \frac{1}{720} \epsilon^{6} \left( 720 a_{5} + 3600 \left( a_{0} \right)^{4} a_{6} + 14400 \left( a_{0} \right)^{3} a_{1} a_{5} + 14400 \left( a_{0} \right)^{3} a_{2} a_{4} + 7200 \left( a_{3} \right)^{2} \left( a_{0} \right)^{3} + 21600 \left( a_{1} \right)^{2} \left( a_{0} \right)^{2} a_{4} + 43200 \left( a_{0} \right)^{2} a_{1} a_{2} a_{3} + 7200 \left( a_{2} \right)^{3} \left( a_{0} \right)^{2} + 14400 \left( a_{1} \right)^{3} a_{0} a_{3} + 21600 \left( a_{2} \right)^{2} \left( a_{1} \right)^{2} a_{0} + 3600 \left( a_{1} \right)^{4} a_{2} \right) + \frac{1}{5040} \epsilon^{7} \left( 5040 a_{6} + 25200 \left( a_{0} \right)^{4} a_{7} + 100800 \left( a_{0} \right)^{3} a_{1} a_{6} + 100800 \left( a_{0} \right)^{3} a_{2} a_{5} + 100800 \left( a_{0} \right)^{3} a_{3} a_{4} + 151200 \left( a_{1} \right)^{2} \left( a_{0} \right)^{2} a_{5} + 302400 \left( a_{0} \right)^{2} a_{1} a_{2} a_{4} + 151200 \left( a_{3} \right)^{2} \left( a_{0} \right)^{2} a_{1} + 151200 \left( a_{2} \right)^{2} \left( a_{0} \right)^{2} a_{3} + 100800 \left( a_{1} \right)^{3} a_{0} a_{4} + 302400 \left( a_{1} \right)^{2} a_{0} a_{2} a_{3} + 100800 \left( a_{2} \right)^{3} a_{0} a_{1} + 25200 \left( a_{1} \right)^{4} a_{3} + 50400 \left( a_{2} \right)^{2} \left( a_{1} \right)^{3} \right) = 1
\end{equation}
 \]</p><p>This messy equation must hold for each power of <span>$ϵ$</span>, so we can separate it into one nicer equation per order:</p><pre><code class="language-julia hljs">quintic_eqs = taylor_coeff(quintic_taylor, ϵ, 0:7)
quintic_eqs[1:5] # for readability, show only 5 shortest equations</code></pre><p class="math-container">\[ \begin{align}
\left( a_{0} \right)^{5} &amp;= 1 \\
a_{0} + 5 \left( a_{0} \right)^{4} a_{1} &amp;= 0 \\
\frac{1}{2} \left( 2 a_{1} + 10 \left( a_{0} \right)^{4} a_{2} + 20 \left( a_{1} \right)^{2} \left( a_{0} \right)^{3} \right) &amp;= 0 \\
\frac{1}{6} \left( 6 a_{2} + 30 \left( a_{0} \right)^{4} a_{3} + 120 \left( a_{0} \right)^{3} a_{1} a_{2} + 60 \left( a_{1} \right)^{3} \left( a_{0} \right)^{2} \right) &amp;= 0 \\
\frac{1}{24} \left( 24 a_{3} + 120 \left( a_{0} \right)^{4} a_{4} + 480 \left( a_{0} \right)^{3} a_{1} a_{3} + 240 \left( a_{2} \right)^{2} \left( a_{0} \right)^{3} + 720 \left( a_{1} \right)^{2} \left( a_{0} \right)^{2} a_{2} + 120 \left( a_{1} \right)^{4} a_{0} \right) &amp;= 0
\end{align}
 \]</p><p>These equations show three important features of perturbation theory:</p><ol><li>The <span>$0$</span>-th order equation is <em>trivial</em> in <span>$x_0$</span>: here <span>$x_0^5 = 1$</span> has the trivial real solution <span>$x_0 = 1$</span>.</li><li>The <span>$n$</span>-th order equation is <em>linear</em> in <span>$x_n$</span> (except the trivial <span>$0$</span>-th order equation).</li><li>The equations are <em>triangular</em> in <span>$x_n$</span>: the <span>$n$</span>-th order equation can be solved for <span>$x_n$</span> given only <span>$x_m$</span> for <span>$m&lt;n$</span>.</li></ol><p>This structure is what makes the perturbation theory so attractive: we can start with the trivial solution <span>$x_0 = 1$</span>, then linearly solve for <span>$x_n$</span> order-by-order and substitute in the solutions of <span>$x_m$</span> for <span>$m&lt;n$</span> obtained so far.</p><p>Here is a simple function that uses this <em>cascading</em> strategy to solve such a set of equations <code>eqs</code> for the variables <code>xs</code>, given a solution <code>x₀</code> of the first equation <code>eqs[begin]</code>:</p><pre><code class="language-julia hljs">function solve_cascade(eqs, xs, x₀, ϵ)
    sol = Dict(xs[begin] =&gt; x₀) # store solutions in a map

    # verify that x₀ is a solution of the first equation
    eq0 = substitute(eqs[1], sol)
    isequal(eq0.lhs, eq0.rhs) || error(&quot;$sol does not solve $(eqs[1])&quot;)

    # solve remaining equations sequentially
    for i in 2:length(eqs)
        eq = substitute(eqs[i], sol) # insert previous solutions
        x = xs[begin+i-1] # need not be 1-indexed
        xsol = Symbolics.symbolic_linear_solve(eq, x) # solve current equation
        sol = merge(sol, Dict(x =&gt; xsol)) # store solution
    end

    return sol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve_cascade (generic function with 1 method)</code></pre><p>Let us solve our order-separated quintics for the coefficients, and substitute them into the full series for <span>$x$</span>:</p><pre><code class="language-julia hljs">x_coeffs_sol = solve_cascade(quintic_eqs, x_coeffs, 1, ϵ)
x_pert = substitute(x_taylor, x_coeffs_sol)</code></pre><p class="math-container">\[ \begin{equation}
1 - \frac{1}{5} \epsilon - \frac{1}{25} \epsilon^{2} - \frac{1}{125} \epsilon^{3} + \frac{21}{15625} \epsilon^{5} + \frac{78}{78125} \epsilon^{6} + \frac{187}{390625} \epsilon^{7}
\end{equation}
 \]</p><p>The <span>$n$</span>-th order solution of our original quintic equation is the sum up to the <span>$ϵ^n$</span>-th order term, evaluated at <span>$ϵ=1$</span>:</p><pre><code class="language-julia hljs">for n in 0:7
    x_pert_sol = substitute(taylor(x_pert, ϵ, 0:n), ϵ =&gt; 1)
    println(&quot;$n-th order solution: x = $x_pert_sol = $(x_pert_sol * 1.0)&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0-th order solution: x = 1//1 = 1.0
1-th order solution: x = 4//5 = 0.8
2-th order solution: x = 19//25 = 0.76
3-th order solution: x = 94//125 = 0.752
4-th order solution: x = 94//125 = 0.752
5-th order solution: x = 11771//15625 = 0.753344
6-th order solution: x = 58933//78125 = 0.7543424
7-th order solution: x = 294852//390625 = 0.75482112</code></pre><p>This is close to the solution from Newton&#39;s method!</p><h2 id="Solving-Kepler&#39;s-Equation"><a class="docs-heading-anchor" href="#Solving-Kepler&#39;s-Equation">Solving Kepler&#39;s Equation</a><a id="Solving-Kepler&#39;s-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Kepler&#39;s-Equation" title="Permalink"></a></h2><p>Historically, perturbation methods were first invented to calculate orbits of the Moon and the planets. In homage to this history, our second example is to solve <a href="https://en.wikipedia.org/wiki/Kepler&#39;s_equation">Kepler&#39;s equation</a>, which is central to solving two-body Keplerian orbits:</p><pre><code class="language-julia hljs">@variables e E M
kepler = E - e * sin(E) ~ M</code></pre><p class="math-container">\[ \begin{equation}
E - e \sin\left( E \right) = M
\end{equation}
 \]</p><p>We want to solve for the <em>eccentric anomaly</em> <span>$E$</span> given the <em>eccentricity</em> <span>$e$</span> and <em>mean anomaly</em> <span>$M$</span>. This is also easy with Newton&#39;s method. With Earth&#39;s eccentricity <span>$e = 0.01671$</span> and <span>$M = \pi/2$</span>:</p><pre><code class="language-julia hljs">vals_earth = Dict(e =&gt; 0.01671, M =&gt; π/2)
E_newton = solve_newton(substitute(kepler, vals_earth), E, π/2)
println(&quot;Newton&#39;s method solution: E = &quot;, E_newton)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Newton&#39;s method solution: E = 1.5875039945829585</code></pre><p>Next, let us solve the same problem with the perturbative method. It is most common to expand <span>$E$</span> as a series in <span>$M$</span>. Repeating the procedure from the quintic example, we get these equations:</p><pre><code class="language-julia hljs">E_taylor = series(E, M, 0:5) # this auto-creates coefficients E[0:5]
E_coeffs = taylor_coeff(E_taylor, M) # get a handle to the coefficients
kepler_eqs = taylor_coeff(substitute(kepler, E =&gt; E_taylor), M, 0:5)
kepler_eqs[1:4] # for readability</code></pre><p class="math-container">\[ \begin{align}
E_{0} - e \sin\left( E_{0} \right) &amp;= 0 \\
E_{1} - E_{1} e \cos\left( E_{0} \right) &amp;= 1 \\
\frac{1}{2} \left( 2 E_{2} - 2 E_{2} e \cos\left( E_{0} \right) + \left( E_{1} \right)^{2} e \sin\left( E_{0} \right) \right) &amp;= 0 \\
\frac{1}{6} \left( 6 E_{3} - 6 E_{3} e \cos\left( E_{0} \right) + 6 E_{1} E_{2} e \sin\left( E_{0} \right) + \left( E_{1} \right)^{3} e \cos\left( E_{0} \right) \right) &amp;= 0
\end{align}
 \]</p><p>The trivial <span>$0$</span>-th order solution (when <span>$M=0$</span>) is <span>$E_0=0$</span>. This gives this full perturbative solution:</p><pre><code class="language-julia hljs">E_coeffs_sol = solve_cascade(kepler_eqs, E_coeffs, 0, M)
E_pert = substitute(E_taylor, E_coeffs_sol)</code></pre><p class="math-container">\[ \begin{equation}
\frac{ - M^{5} \left( \frac{ - 60 \left( \frac{-1}{-1 + e} \right)^{5} e^{2}}{6 - 6 e} - \left( \frac{-1}{-1 + e} \right)^{5} e \right)}{120 - 120 e} + \frac{ - M}{-1 + e} + \frac{ - \left( \frac{-1}{-1 + e} \right)^{3} M^{3} e}{6 - 6 e}
\end{equation}
 \]</p><p>Numerically, the result again converges to that from Newton&#39;s method:</p><pre><code class="language-julia hljs">for n in 0:5
    println(&quot;$n-th order solution: E = &quot;, substitute(taylor(E_pert, M, 0:n), vals_earth))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0-th order solution: E = 0//1
1-th order solution: E = 1.59749039123239
2-th order solution: E = 1.59749039123239
3-th order solution: E = 1.585943679042236
4-th order solution: E = 1.585943679042236
5-th order solution: E = 1.5876674054288387</code></pre><p>But unlike Newtons method, this example shows how perturbation theory also gives us the powerful <em>symbolic</em> series solution for <span>$E$</span> (<em>before</em> numbers for <span>$e$</span> and <span>$M$</span> are inserted). Our series matches <a href="https://en.wikipedia.org/wiki/Kepler%27s_equation#Inverse_Kepler_equation">this result from Wikipedia</a>:</p><pre><code class="language-julia hljs">E_wiki = 1/(1-e)*M - e/(1-e)^4*M^3/factorial(3) + (9e^2+e)/(1-e)^7*M^5/factorial(5)</code></pre><p class="math-container">\[ \begin{equation}
\frac{M}{1 - e} + \frac{\frac{1}{120} M^{5} \left( e + 9 e^{2} \right)}{\left( 1 - e \right)^{7}} + \frac{ - \frac{1}{6} M^{3} e}{\left( 1 - e \right)^{4}}
\end{equation}
 \]</p><p>Alternatively, we can expand <span>$E$</span> in <span>$e$</span> instead of <span>$M$</span>, giving the solution (the trivial solution when <span>$e = 0$</span> is <span>$E_0=M$</span>):</p><pre><code class="language-julia hljs">E_taylor′ = series(E, e, 0:5)
E_coeffs′ = taylor_coeff(E_taylor′, e)
kepler_eqs′ = taylor_coeff(substitute(kepler, E =&gt; E_taylor′), e, 0:5)
E_coeffs_sol′ = solve_cascade(kepler_eqs′, E_coeffs′, M, e)
E_pert′ = substitute(E_taylor′, E_coeffs_sol′)</code></pre><p class="math-container">\[ \begin{equation}
M + e \sin\left( M \right) + e^{2} \sin\left( M \right) \cos\left( M \right) - \frac{1}{6} e^{3} \left( 3 \sin^{3}\left( M \right) - 6 \cos^{2}\left( M \right) \sin\left( M \right) \right) - \frac{1}{24} e^{4} \left( 28 \sin^{3}\left( M \right) \cos\left( M \right) + 4 \left( 3 \sin^{3}\left( M \right) - 6 \cos^{2}\left( M \right) \sin\left( M \right) \right) \cos\left( M \right) \right) - \frac{1}{120} e^{5} \left(  - 5 \sin^{5}\left( M \right) + 120 \cos^{2}\left( M \right) \sin^{3}\left( M \right) + 5 \left( 28 \sin^{3}\left( M \right) \cos\left( M \right) + 4 \left( 3 \sin^{3}\left( M \right) - 6 \cos^{2}\left( M \right) \sin\left( M \right) \right) \cos\left( M \right) \right) \cos\left( M \right) - 20 \sin^{2}\left( M \right) \left( 3 \sin^{3}\left( M \right) - 6 \cos^{2}\left( M \right) \sin\left( M \right) \right) \right)
\end{equation}
 \]</p><p>This looks very different from our first series <code>E_pert</code>. If they are the same, we should get <span>$0$</span> if we subtract and expand both as multivariate Taylor series in <span>$(e,M)$</span>. Indeed:</p><pre><code class="language-julia hljs">taylor(taylor(E_pert′ - E_pert, e, 0:4), M, 0:4)</code></pre><p class="math-container">\[ \begin{equation}
0
\end{equation}
 \]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../converting_to_C/">« Automatic Conversion of Julia Code to C Functions</a><a class="docs-footer-nextpage" href="../../manual/variables/">Variable and Equation Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 16:02">Friday 1 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
