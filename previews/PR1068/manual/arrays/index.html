<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Arrays · Symbolics.jl</title><meta name="title" content="Symbolic Arrays · Symbolics.jl"/><meta property="og:title" content="Symbolic Arrays · Symbolics.jl"/><meta property="twitter:title" content="Symbolic Arrays · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/arrays/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/arrays/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/arrays/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li class="is-active"><a class="tocitem" href>Symbolic Arrays</a><ul class="internal"><li><a class="tocitem" href="#Symbolic-Arrays-vs-Arrays-of-Symbolic-Expressions"><span>Symbolic Arrays vs Arrays of Symbolic Expressions</span></a></li><li><a class="tocitem" href="#Using-Symbolic-Arrays"><span>Using Symbolic Arrays</span></a></li><li><a class="tocitem" href="#Array-operations"><span>Array operations</span></a></li></ul></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Symbolic Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/arrays.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="symbolic_arrays"><a class="docs-heading-anchor" href="#symbolic_arrays">Symbolic Arrays</a><a id="symbolic_arrays-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_arrays" title="Permalink"></a></h1><h2 id="Symbolic-Arrays-vs-Arrays-of-Symbolic-Expressions"><a class="docs-heading-anchor" href="#Symbolic-Arrays-vs-Arrays-of-Symbolic-Expressions">Symbolic Arrays vs Arrays of Symbolic Expressions</a><a id="Symbolic-Arrays-vs-Arrays-of-Symbolic-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Arrays-vs-Arrays-of-Symbolic-Expressions" title="Permalink"></a></h2><p>Symbolics.jl contains two forms for handling symbolic arrays:</p><ol><li>Arrays of symbolic expressions: these are Julia arrays with Symbolics.jl objects in them.</li><li>Symbolic Arrays: these are symbolic (O(1)) representations of arrays.</li></ol><p>Arrays of symbolic expressions are simply Symbolics.jl objects put into Julia arrays. For example:</p><pre><code class="language-julia hljs">using Symbolics
@variables x y
u = [x,y]</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
x \\
y \\
\end{array}
\right]
\end{equation}
 \]</p><p>is a vector of two symbolic variables. As shorthand,</p><pre><code class="language-julia hljs">u2 = Symbolics.variables(:x, 1:3, 3:6)</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{cccc}
x_{1}ˏ_3 &amp; x_{1}ˏ_4 &amp; x_{1}ˏ_5 &amp; x_{1}ˏ_6 \\
x_{2}ˏ_3 &amp; x_{2}ˏ_4 &amp; x_{2}ˏ_5 &amp; x_{2}ˏ_6 \\
x_{3}ˏ_3 &amp; x_{3}ˏ_4 &amp; x_{3}ˏ_5 &amp; x_{3}ˏ_6 \\
\end{array}
\right]
\end{equation}
 \]</p><p>creates a Julia matrix of symbolic variables. Indexing <code>u</code> or <code>u2</code> gives symbolic values which act as a normal scalar symbolic value. This form these uses Julia&#39;s array functionality and performs symbolic operations on the scalar values.</p><p>On the otherhand, Julia&#39;s symbolic array form is an O(1) representation of the whole array.</p><pre><code class="language-julia hljs">@variables A[1:5, 1:3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Symbolics.Arr{Num, 2}}:
 A[1:5,1:3]</code></pre><p>When using this form, <code>A[1,1]</code> is not a symbolic variable but a symbolic expression for indexing the variable <code>A</code>. This representation holds linear algebra expressions in a non-expanded form. For example:</p><pre><code class="language-julia hljs">@variables B[1:3, 1:3]
A * B</code></pre><p class="math-container">\[ \begin{equation}
A B
\end{equation}
 \]</p><p>in comparison to:</p><pre><code class="language-julia hljs">a = Symbolics.variables(:a, 1:5, 1:3)
b = Symbolics.variables(:b, 1:3, 1:3)
a * b</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{ccc}
a_{1}ˏ_1 b_{1}ˏ_1 + a_{1}ˏ_2 b_{2}ˏ_1 + a_{1}ˏ_3 b_{3}ˏ_1 &amp; a_{1}ˏ_1 b_{1}ˏ_2 + a_{1}ˏ_2 b_{2}ˏ_2 + a_{1}ˏ_3 b_{3}ˏ_2 &amp; a_{1}ˏ_1 b_{1}ˏ_3 + a_{1}ˏ_2 b_{2}ˏ_3 + a_{1}ˏ_3 b_{3}ˏ_3 \\
a_{2}ˏ_1 b_{1}ˏ_1 + a_{2}ˏ_2 b_{2}ˏ_1 + a_{2}ˏ_3 b_{3}ˏ_1 &amp; a_{2}ˏ_1 b_{1}ˏ_2 + a_{2}ˏ_2 b_{2}ˏ_2 + a_{2}ˏ_3 b_{3}ˏ_2 &amp; a_{2}ˏ_1 b_{1}ˏ_3 + a_{2}ˏ_2 b_{2}ˏ_3 + a_{2}ˏ_3 b_{3}ˏ_3 \\
a_{3}ˏ_1 b_{1}ˏ_1 + a_{3}ˏ_2 b_{2}ˏ_1 + a_{3}ˏ_3 b_{3}ˏ_1 &amp; a_{3}ˏ_1 b_{1}ˏ_2 + a_{3}ˏ_2 b_{2}ˏ_2 + a_{3}ˏ_3 b_{3}ˏ_2 &amp; a_{3}ˏ_1 b_{1}ˏ_3 + a_{3}ˏ_2 b_{2}ˏ_3 + a_{3}ˏ_3 b_{3}ˏ_3 \\
a_{4}ˏ_1 b_{1}ˏ_1 + a_{4}ˏ_2 b_{2}ˏ_1 + a_{4}ˏ_3 b_{3}ˏ_1 &amp; a_{4}ˏ_1 b_{1}ˏ_2 + a_{4}ˏ_2 b_{2}ˏ_2 + a_{4}ˏ_3 b_{3}ˏ_2 &amp; a_{4}ˏ_1 b_{1}ˏ_3 + a_{4}ˏ_2 b_{2}ˏ_3 + a_{4}ˏ_3 b_{3}ˏ_3 \\
a_{5}ˏ_1 b_{1}ˏ_1 + a_{5}ˏ_2 b_{2}ˏ_1 + a_{5}ˏ_3 b_{3}ˏ_1 &amp; a_{5}ˏ_1 b_{1}ˏ_2 + a_{5}ˏ_2 b_{2}ˏ_2 + a_{5}ˏ_3 b_{3}ˏ_2 &amp; a_{5}ˏ_1 b_{1}ˏ_3 + a_{5}ˏ_2 b_{2}ˏ_3 + a_{5}ˏ_3 b_{3}ˏ_3 \\
\end{array}
\right]
\end{equation}
 \]</p><p>This makes the symbolic array form much more efficient, but requires that the expressions uses things with registered symbolic array functions which currently has much lower coverage. Also, there are many fallbacks for which arrays of symbolics which makes this approach more accessible but with larger expressions.</p><p>We recommend defaulting to arrays of symbolics unless you need the expression symplifications of the symbolic array approach.</p><h2 id="Using-Symbolic-Arrays"><a class="docs-heading-anchor" href="#Using-Symbolic-Arrays">Using Symbolic Arrays</a><a id="Using-Symbolic-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Symbolic-Arrays" title="Permalink"></a></h2><p>Symbolic array-valued expressions (symbolic arrays) are supported by Symbolics. Symbolic array expressions propagate useful metadata that depends on input arrays: array dimension, element type and shape.</p><p>You can create a symbolic array variable with the following syntax:</p><pre><code class="language-julia hljs">using Symbolics
@variables A[1:5, 1:3] b[1:3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Symbolics.Arr{Num}}:
 A[1:5,1:3]
 b[1:3]</code></pre><p>Here, <code>A</code> is a symbolic matrix of size <code>(5, 3)</code> and <code>b</code> is a symbolic vector of length 3.</p><pre><code class="language-julia hljs">size(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(5, 3)</code></pre><pre><code class="language-julia hljs">size(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3,)</code></pre><pre><code class="language-julia hljs">ndims(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><pre><code class="language-julia hljs">ndims(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><pre><code class="language-julia hljs">eltype(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Real</code></pre><pre><code class="language-julia hljs">eltype(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Real</code></pre><h2 id="Array-operations"><a class="docs-heading-anchor" href="#Array-operations">Array operations</a><a id="Array-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Array-operations" title="Permalink"></a></h2><p>Operations on symbolic arrays return symbolic array expressions:</p><pre><code class="language-julia hljs">c = A * b</code></pre><p class="math-container">\[ \begin{equation}
A b
\end{equation}
 \]</p><pre><code class="language-julia hljs">size(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(5,)</code></pre><pre><code class="language-julia hljs">eltype(c)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Real</code></pre><p>Adjoints, matrix-matrix, and matrix-vector multiplications are supported. Dot product returns a scalar-valued expression:</p><pre><code class="language-julia hljs">b&#39;b</code></pre><p class="math-container">\[ \begin{equation}
adjoint(b) * b_1
\end{equation}
 \]</p><pre><code class="language-julia hljs">size(b&#39;b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">()</code></pre><p>Outer product returns a matrix:</p><pre><code class="language-julia hljs">b * b&#39;</code></pre><p class="math-container">\[ \begin{equation}
b \mathrm{adjoint}\left( b \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">size(b*b&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(3, 3)</code></pre><h3 id="Broadcast,-map-and-reduce"><a class="docs-heading-anchor" href="#Broadcast,-map-and-reduce">Broadcast, map and reduce</a><a id="Broadcast,-map-and-reduce-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcast,-map-and-reduce" title="Permalink"></a></h3><pre><code class="language-julia hljs">A .* b&#39;</code></pre><p class="math-container">\[ \begin{equation}
\mathrm{broadcast}\left( *, A, \mathrm{adjoint}\left( b \right) \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">map(asin, (A*b))</code></pre><p class="math-container">\[ \begin{equation}
\mathrm{map}\left( \arcsin, A b \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">#sum(A) #latexify not working</code></pre><pre><code class="language-julia hljs">typeof(sum(A))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Num</code></pre><pre><code class="language-julia hljs">typeof(sum(A, dims=2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Symbolics.Arr{Num, 2}</code></pre><h3 id="Indexing-and-delayed-computation"><a class="docs-heading-anchor" href="#Indexing-and-delayed-computation">Indexing and delayed computation</a><a id="Indexing-and-delayed-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-delayed-computation" title="Permalink"></a></h3><p>Indexing array expressions is fairly flexible in Symbolics. Let&#39;s go through all the possible ways to index arrays.</p><h4 id="Scalar-indexing-and-scalarization"><a class="docs-heading-anchor" href="#Scalar-indexing-and-scalarization">Scalar indexing and scalarization</a><a id="Scalar-indexing-and-scalarization-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-indexing-and-scalarization" title="Permalink"></a></h4><pre><code class="language-julia hljs">AAt = A*A&#39;</code></pre><p class="math-container">\[ \begin{equation}
A \mathrm{adjoint}\left( A \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">AAt[2,3]</code></pre><p class="math-container">\[ \begin{equation}
A * adjoint(A)_{2}ˏ_3
\end{equation}
 \]</p><p>Here we indexed for the element (2,3), but we got back a symbolic indexing expression. You may want to force the element to be computed in terms of the elements of A. This can be done, using the <code>scalarize</code> function.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../groebner/">« Groebner bases</a><a class="docs-footer-nextpage" href="../build_function/">Function Building and Compilation (build_function) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 22 February 2024 05:06">Thursday 22 February 2024</span>. Using Julia version 1.10.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
