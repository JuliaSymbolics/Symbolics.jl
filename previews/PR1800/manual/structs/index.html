<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic Structs · Symbolics.jl</title><meta name="title" content="Symbolic Structs · Symbolics.jl"/><meta property="og:title" content="Symbolic Structs · Symbolics.jl"/><meta property="twitter:title" content="Symbolic Structs · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/structs/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/structs/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/structs/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li><li><a class="tocitem" href="../../tutorials/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../external/">Working with External Symbolics Packages: SymPy, Mathematica, Oscar, and Beyond</a></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Algebra</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solver/">Solving Symbolic Equations</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li><a class="tocitem" href="../constraint_satisfaction/">Constraint Satisfaction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Calculus</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../integration/">Symbolic Integrals</a></li><li><a class="tocitem" href="../ode/">Symbolic ODE Solving</a></li><li><a class="tocitem" href="../taylor/">Taylor Series</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li><li><a class="tocitem" href="../misc/">Miscellaneous API</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Symbolic Structs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic Structs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/structs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Symbolic-Structs"><a class="docs-heading-anchor" href="#Symbolic-Structs">Symbolic Structs</a><a id="Symbolic-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Structs" title="Permalink"></a></h1><p>It is occasionally useful to represent structs symbolically, and retain the ability to perform <code>getproperty</code> on them. For example, let us consider the following struct representing a point in 2D cartesian coordinates.</p><pre><code class="language-julia hljs">using Symbolics, SymbolicUtils

struct Point2D{T}
    x::T
    y::T
end</code></pre><p>To allow this struct to be used symbolically, the <a href="#Symbolics.@symstruct"><code>@symstruct</code></a> macro must be used:</p><pre><code class="language-julia hljs">@symstruct Point2D{T}</code></pre><p>Note that this macro <em>requires</em> that all type parameters of the struct be present in the macro use. With this, we can create symbolic structs like any other variable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables point::Point2D{Real}</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymStruct{Main.Point2D{Real}}}:
 point</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(point)</code><code class="nohighlight hljs ansi" style="display:block;">SymStruct{Main.Point2D{Real}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert point.x isa Num</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert point.y isa Num</code></pre><p>Subsequently, fields of the struct can be accessed symbolically:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; point.x^2 + point.y^2</code><code class="nohighlight hljs ansi" style="display:block;">point.x^<span class="sgr34">2</span> + point.y^<span class="sgr34">2</span></code></pre><h2 id="Array-fields"><a class="docs-heading-anchor" href="#Array-fields">Array fields</a><a id="Array-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Array-fields" title="Permalink"></a></h2><p>What if we have a general point type capable of representing arbitrary dimensional cartesian coordinates?</p><pre><code class="language-julia hljs">struct PointN{T, N}
    x::Vector{T}

    function PointN{T, N}(x::Vector{T}) where {T, N}
        @assert length(x) == N
        new{T, N}(x)
    end
end</code></pre><p>The standard <code>@symstruct PointN{T, N}</code> would work. However, Symbolics cannot infer the length of field <code>x</code> simply from the type <code>PointN{T, N}</code>. As a result, the field would be inferred as an unknown length vector, and allow arbitrary indexing such as <code>point.x[1234]</code>. To provide this information, the <code>@symstruct</code> macro allows specifying additional metadata:</p><pre><code class="language-julia hljs">@symstruct PointN{T, N} begin
    shape(:x) = (1:N,)
end</code></pre><p>The <code>shape</code> option allows specifying the shape of array fields. Here, we&#39;re saying that the shape of field <code>:x</code> is <code>(1:N,)</code> (i.e. it is a 1-indexed vector of length <code>N</code>). The expression can use type information of the registered struct type. The specific details of all options are documented in the <a href="#Symbolics.@symstruct"><code>@symstruct</code></a> macro. With the above declaration, we can now have safe symbolic <code>PointN</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables point::PointN{Real, 3}</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymStruct{Main.PointN{Real, 3}}}:
 point</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; point.x[1]^2 + point.x[2]^2 + point.x[3]^2</code><code class="nohighlight hljs ansi" style="display:block;">(point.x)[<span class="sgr34">1</span>]^<span class="sgr34">2</span> + (point.x)[<span class="sgr34">2</span>]^<span class="sgr34">2</span> + (point.x)[<span class="sgr34">3</span>]^<span class="sgr34">2</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(point.x) == (3,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; try
           point.x[4]
       catch e
           Base.showerror(e)
       end</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching showerror(::BoundsError)
The function `showerror` exists, but no method is defined for this combination of argument types.

Closest candidates are:
  showerror(<span class="sgr91">::IO</span>, <span class="sgr91">::UndefRefError</span>)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">errorshow.jl:162</span></span>
  showerror(<span class="sgr91">::IO</span>, <span class="sgr91">::Latexify.UnrepresentableException</span>)
<span class="sgr90">   @</span> <span class="sgr35">Latexify</span> <span class="sgr90">~/.julia/packages/Latexify/IJYMW/src/<span class="sgr4">error.jl:24</span></span>
  showerror(<span class="sgr91">::IO</span>, <span class="sgr91">::DimensionMismatch</span>)
<span class="sgr90">   @</span> <span class="sgr90">Base</span> <span class="sgr90"><span class="sgr4">errorshow.jl:170</span></span>
  ...</code></pre><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>Often, it is useful to specify that all subtypes of a given abstract type should be considered symbolic structs. The <code>@symstruct</code> macro can be used on abstract types to enable this behavior.</p><pre><code class="language-julia hljs">abstract type AbstractRecord{T} end

struct Record1{T} &lt;: AbstractRecord{T}
    x::Vector{T}
    y::T
end

struct Record2{T} &lt;: AbstractRecord{T}
    x::Vector{T}
    z::T
end

@symstruct AbstractRecord{T} begin
    shape(:x) = (1:3,)
end</code></pre><p>As evidenced above, even options such as <code>shape</code> can be specified for abstract types. These are applicable to all subtypes.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables rec1::Record1{Real} rec2::Record2{Real}</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymStruct}:
 rec1
 rec2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(rec1.x) == (3,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(rec2.x) == (3,)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rec1.x[1] + rec2.x[2] + rec1.y + rec2.z</code><code class="nohighlight hljs ansi" style="display:block;">rec1.y + (rec2.x)[<span class="sgr34">2</span>] + (rec1.x)[<span class="sgr34">1</span>] + rec2.z</code></pre><p>The <code>@symstruct</code> macro roughly follows Julia subtyping behavior. This means that more specific <code>@symstruct</code> declarations override less specific ones.</p><pre><code class="language-julia hljs">struct Record3{T} &lt;: AbstractRecord{T}
    x::Vector{T}
    w::T
end

@symstruct Record3{T} begin
    shape(:x) = (1:4,)
end

struct Record4{T} &lt;: AbstractRecord{T}
    x::Vector{T}
    f::Vector{T}
end

@symstruct Record4{T} begin
    shape(:f) = (1:5,)
end</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables rec3::Record3{Real} rec4::Record4{Real}</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{SymStruct}:
 rec3
 rec4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(rec3.x) == (4,) # Different from the one declared by `AbstractRecord`</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(rec4.x) == (3,) # Falls back to the `AbstractRecord` definition</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @assert size(rec4.f) == (5,) # Uses the more specific declaration</code></pre><h2 id="Arrays-of-symbolic-structs"><a class="docs-heading-anchor" href="#Arrays-of-symbolic-structs">Arrays of symbolic structs</a><a id="Arrays-of-symbolic-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Arrays-of-symbolic-structs" title="Permalink"></a></h2><p>Arrays of symbolic structs are required to have a concrete <code>eltype</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables pts[1:3]::PointN{Real, 3}</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{Symbolics.Arr{SymStruct{Main.PointN{Real, 3}}, 1}}:
 pts[1:3]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; pts[1].x[1] + pts[2].x[2]</code><code class="nohighlight hljs ansi" style="display:block;">(pts[<span class="sgr34">2</span>].x)[<span class="sgr34">2</span>] + (pts[<span class="sgr34">1</span>].x)[<span class="sgr34">1</span>]</code></pre><h2 id="Nested-structs"><a class="docs-heading-anchor" href="#Nested-structs">Nested structs</a><a id="Nested-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Nested-structs" title="Permalink"></a></h2><p>Symbolic struct types can be nested inside each other.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @variables recs::Record1{Record1{Real}}</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{SymStruct{Main.Record1{Main.Record1{Real}}}}:
 recs</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; recs.x[1].x[1] + recs.x[2].y.y</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: FieldError: type Num has no field `y`, available fields: `val`</code></pre><h2 id="Registered-functions-of-symbolic-structs"><a class="docs-heading-anchor" href="#Registered-functions-of-symbolic-structs">Registered functions of symbolic structs</a><a id="Registered-functions-of-symbolic-structs-1"></a><a class="docs-heading-anchor-permalink" href="#Registered-functions-of-symbolic-structs" title="Permalink"></a></h2><p>There is some unique behavior when registering functions where arguments are (arrays of) symbolic structs. The <code>@symstruct</code> macro works by defining some interface functions to allow using the <code>Symbolics.SymStruct</code> wrapper type, similar to how <code>Num</code> is a wrapper type. All registration functions behave the same as they did prior to this feature if the <code>SymStruct</code> is unwrapped (using <code>SymbolicUtils.unwrap</code>). The difference in behavior arises from how wrapped <code>SymStruct</code> types are handled. In general, the <code>@register_symbolic</code> and <code>@register_array_symbolic</code> macros can only use information from the provided type annotations. They cannot know to declare methods for <code>SymStruct{ConcreteFoo}</code> if the function is registered with <code>AbstractFoo</code>. For example, the following syntax:</p><pre><code class="language-julia hljs">@register_symbolic foofn(foo::AbstractFoo)</code></pre><p>Will only work for a variable declared as <code>@variables foo::ConcreteFoo</code> if <code>@symstruct AbstractFoo</code> is declared, regardless of whether <code>@symstruct ConcreteFoo</code> is declared or not. This will always work for <code>@variables afoo::AbstractFoo</code>.</p><pre><code class="language-julia hljs">@register_symbolic foofn2(foos::Vector{AbstractFoo})</code></pre><p>Suppose we have declared <code>@variables a::ConcreteFoo b::ConcreteFoo cs[1:3]::ConcreteFoo</code>. <code>foofn2([a, b])</code> will work only if <code>@symstruct AbstractFoo</code> is declared, regardless of whether <code>@symstruct ConcreteFoo</code> is declared or not. The same applies for <code>foofn2(cs)</code>.</p><p>If you are not using symbolic structs, the registration macros behave exactly as they did prior to this feature.</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Symbolics.@symstruct"><a class="docstring-binding" href="#Symbolics.@symstruct"><code>Symbolics.@symstruct</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@symstruct Foo{T1, T2, ...}
@symstruct Foo{T1, T2, ...} begin
  # options...
end</code></pre><p>A macro which enables using type <code>Foo</code> with <code>SymStruct</code> as a symbolic struct. The first argument to the macro must be the struct type, with all type parameters named. The optional second argument is an optional <code>begin..end</code> block containing options that influence the behavior of the macro. The following options are allowed:</p><ul><li><code>shape(:field) = # expression</code>. For array fields, the shape of the field cannot be inferred from the type. In case the type of the field can be inferred from the type, it can be specified using this syntax. The expression must evaluate to an object of type <code>Union{SymbolicUtils.Unknown, AbstractVector{UnitRange{Int}}, Tuple{Vararg{UnitRange{Int}}}}</code>. The expression has access to the concrete type of the struct being accessed, with all type parameters available as declared in the first argument.</li></ul><p>For example, given the following struct:</p><pre><code class="language-julia hljs">struct Record{T}
  x::Int
  y::Real
  z::T
end</code></pre><p>It can be registered as</p><pre><code class="language-julia hljs"># Note: the type parameter must be declared, but the name itself does not matter
@symstruct Record{V} begin
# If `V` is an `AbstractVector` then field `z` is a 3-vector. Otherwise, it is a scalar.
  shape(:z) = V &lt;: AbstractVector ? [1:3] : ()
end</code></pre><p>Now,</p><pre><code class="language-julia hljs">@variables rec::Record{Int} rec2::Record{Vector{Int}}</code></pre><p><code>rec.x</code>, <code>rec2.x</code> will be <code>Num</code>s with symtype <code>Int</code>. <code>rec.y</code> and <code>rec2.y</code> will be <code>Num</code>s with symtype <code>Real</code>. <code>rec.z</code> will be a <code>Num</code> with symtype <code>Int</code>. <code>rec2.z</code> will be an <code>Arr{Num, 1}</code> with symtype <code>Vector{Int}</code> and shape <code>[1:2]</code>.</p><p>In case the shape of a field is not provided, it will be inferred from the type. For <code>AbstractArray</code> subtypes, it will be <code>SymbolicUtils.Unknown(ndims(arr_type))</code>. Otherwise, it will be treated as a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/c3255ed132962e3dd7dfbcdc050fc3b04be083f6/src/symstruct.jl#L41-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Symbolics.SymStruct"><a class="docstring-binding" href="#Symbolics.SymStruct"><code>Symbolics.SymStruct</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SymStruct{T}</code></pre><p>Wrapper type for symbolic structs. Requires that the wrapped struct type <code>T</code> be registered with <a href="#Symbolics.@symstruct"><code>@symstruct</code></a>. After registration, <code>@variables</code> can be used to create the symbolic struct.</p><pre><code class="language-julia hljs"># Here, `record` has type `SymStruct{Record}`
@variables record::Record</code></pre><p><code>getproperty</code> access on this is a symbolic operation, and returns an expression performing the appropriate field access. This can only wrap concrete struct types (<code>isconcretetype(T)</code> must be <code>true</code>). <code>getproperty</code> on this struct leverages <code>fieldnames</code> and <code>fieldtypes</code>. Thus, will thus not respect custom <code>getproperty</code> methods on the wrapped struct type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/c3255ed132962e3dd7dfbcdc050fc3b04be083f6/src/symstruct.jl#L1-L17">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 09:56">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
