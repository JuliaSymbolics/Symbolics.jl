<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solver · Symbolics.jl</title><meta name="title" content="Solver · Symbolics.jl"/><meta property="og:title" content="Solver · Symbolics.jl"/><meta property="twitter:title" content="Solver · Symbolics.jl"/><meta name="description" content="Documentation for Symbolics.jl."/><meta property="og:description" content="Documentation for Symbolics.jl."/><meta property="twitter:description" content="Documentation for Symbolics.jl."/><meta property="og:url" content="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><meta property="twitter:url" content="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><link rel="canonical" href="https://docs.sciml.ai/Symbolics/stable/manual/solver/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Symbolics.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Symbolics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting_started/">Getting Started with Symbolics.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/perturbation/">Mixed Symbolic-Numeric Perturbation Theory</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../variables/">Variable and Equation Types</a></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../groebner/">Groebner bases</a></li><li class="is-active"><a class="tocitem" href>Solver</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../arrays/">Symbolic Arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../parsing/">Parsing Julia Expressions to Symbolic Expressions</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../types/">Supported types and dispatch in Symbolics</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../limits/">Symbolic Limits</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solver</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/solver.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solver"><a class="docs-heading-anchor" href="#Solver">Solver</a><a id="Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Solver" title="Permalink"></a></h1><p>The main symbolic solver for Symbolics.jl is <code>symbolic_solve</code>. Symbolic solving means that it only uses symbolic (algebraic) methods and outputs exact solutions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.symbolic_solve" href="#Symbolics.symbolic_solve"><code>Symbolics.symbolic_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_solve(expr, x; dropmultiplicity=true, warns=true)</code></pre><p><code>symbolic_solve</code> is a function which attempts to solve input equations/expressions symbolically using various methods.</p><p><strong>Arguments</strong></p><ul><li><p>expr: Could be a single univar expression in the form of a poly or multiple univar expressions or multiple multivar polys or a transcendental nonlinear function.</p></li><li><p>x: Could be a single variable or an array of variables which should be solved</p></li><li><p>dropmultiplicity (optional): Should the output be printed <code>n</code> times where <code>n</code> is the number of occurrence of the root? Say we have <code>(x+1)^2</code>, we then have 2 roots <code>x = -1</code>, by default the output is <code>[-1]</code>, If dropmultiplicity is inputted as false, then the output is <code>[-1, -1]</code>.</p></li><li><p>warns (optional): When invalid expressions or cases are inputted, should the solver warn you of such cases before returning nothing? if this is set to false, the solver returns nothing. By default, warns are set to true.</p></li></ul><p><strong>Supported input</strong></p><p>The base solver (<code>symbolic_solve</code>) has multiple solvers which chooses from depending on the the type of input (multiple/uni var and multiple/single expression) only after ensuring that the input is valid.</p><p>The expressions inputted can contain parameters, which are assumed to be transcendental. A parameter &quot;a&quot; is transcendental if there exists no polynomial P with rational coefficients such that P(a) = 0. Check the examples section.</p><p>Currently, <code>symbolic_solve</code> supports</p><ul><li>Linear and polynomial equations (with parameters)</li><li>Systems of linear and polynomials equations (without extra parameters, for now)</li><li>Equations with transcendental functions (with parameters)</li></ul><p><strong>Examples</strong></p><p><strong><code>solve_univar</code> (uses factoring and analytic solutions up to degree 4)</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The package <code>Nemo</code> is needed in order to use <code>solve_univar</code> as well as <code>solve_multipoly</code>, so executing <code>using Nemo</code> as you will see in the following examples is necessary; otherwise, the function will throw an error.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics, Nemo;

julia&gt; @variables x a b;

julia&gt; expr = expand((x + b)*(x^2 + 2x + 1)*(x^2 - a))
-a*b - a*x - 2a*b*x - 2a*(x^2) + b*(x^2) + x^3 - a*b*(x^2) - a*(x^3) + 2b*(x^3) + 2(x^4) + b*(x^4) + x^5

julia&gt; symbolic_solve(expr, x)
4-element Vector{Any}:
 -1
   -b
   (1//2)*√(4a)
   (-1//2)*√(4a)

julia&gt; symbolic_solve(expr, x, dropmultiplicity=false)
5-element Vector{Any}:
 -1
 -1
   -b
   (1//2)*√(4a)
   (-1//2)*√(4a)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(x^2 + a*x + 6, x)
2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (1//2)*(-a + √(-24 + a^2))
 (1//2)*(-a - √(-24 + a^2))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(x^7 - 1, x)
2-element Vector{Any}:
  roots_of((1//1) + x + x^2 + x^3 + x^4 + x^5 + x^6, x)
 1</code></pre><p><strong><code>solve_multivar</code> (uses Groebner basis and <code>solve_univar</code> to find roots)</strong></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Similar to <code>solve_univar</code>, <code>Groebner</code> is needed for <code>solve_multivar</code> or to be fully functional.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Groebner

julia&gt; @variables x y z
3-element Vector{Num}:
 x
 y
 z

julia&gt; eqs = [x+y^2+z, z*x*y, z+3x+y]
3-element Vector{Num}:
 x + z + y^2
       x*y*z
  3x + y + z

julia&gt; symbolic_solve(eqs, [x,y,z])
3-element Vector{Any}:
 Dict{Num, Any}(z =&gt; 0, y =&gt; 1//3, x =&gt; -1//9)
 Dict{Num, Any}(z =&gt; 0, y =&gt; 0, x =&gt; 0)
 Dict{Num, Any}(z =&gt; -1, y =&gt; 1, x =&gt; 0)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If <code>Nemo</code> or <code>Groebner</code> are not imported when needed, the solver throws an error.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; using Symbolics

julia&gt; @variables x y z;

julia&gt; symbolic_solve(x+1, x)
ERROR: &quot;Nemo is required. Execute `using Nemo` to enable this functionality.&quot;

julia&gt; symbolic_solve([x+1, y], [x, y])
ERROR: &quot;Groebner bases engine is required. Execute `using Groebner` to enable this functionality.&quot;</code></pre><p><strong><code>solve_multipoly</code> (uses GCD between the input polys)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve([x-1, x^3 - 1, x^2 - 1, (x-1)^20], x)
1-element Vector{BigInt}:
 1</code></pre><p><strong><code>ia_solve</code> (solving by isolation and attraction)</strong></p><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(2^(x+1) + 5^(x+3), x)
1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (-slog(2) - log(complex(-1)) + 3slog(5)) / (slog(2) - slog(5))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(log(x+1)+log(x-1), x)
2-element Vector{SymbolicUtils.BasicSymbolic{BigFloat}}:
 (1//2)*√(8.0)
 (-1//2)*√(8.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; symbolic_solve(a*x^b + c, x)
((-c)^(1 / b)) / (a^(1 / b))</code></pre><p><strong>Evaluating output (converting to floats)</strong></p><p>If you want to evaluate the exact expressions found by <code>symbolic_solve</code>, you can do the following:</p><pre><code class="language-julia-repl hljs">julia&gt; roots = symbolic_solve(2^(x+1) + 5^(x+3), x)
1-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 (-slog(2) - log(complex(-1)) + 3slog(5)) / (slog(2) - slog(5))

julia&gt; Symbolics.symbolic_to_float.(roots)
1-element Vector{Complex{BigFloat}}:
 -4.512941594732059759689023145584186058252768936052415430071569066192919491762214 + 3.428598090438030380369414618548038962770087500755160535832807433942464545729382im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/c1a90e53aff91034a8b33ebd5bd6ebd84048d0ef/src/solver/main.jl#L2-L144">source</a></section></article><p>One other symbolic solver is <code>symbolic_linear_solve</code> which is limited compared to  <code>symbolic_solve</code> as it only solves linear equations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Symbolics.symbolic_linear_solve" href="#Symbolics.symbolic_linear_solve"><code>Symbolics.symbolic_linear_solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolic_linear_solve(eq, var; simplify, check) -&gt; Any
</code></pre><p>Solve equation(s) <code>eqs</code> for a set of variables <code>vars</code>.</p><p>Assumes <code>length(eqs) == length(vars)</code></p><p>Currently only works if all equations are linear. <code>check</code> if the expr is linear w.r.t <code>vars</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; @variables x y
2-element Vector{Num}:
 x
 y

julia&gt; Symbolics.symbolic_linear_solve(x + y ~ 0, x)
-y

julia&gt; Symbolics.symbolic_linear_solve([x + y ~ 0, x - y ~ 2], [x, y])
2-element Vector{Float64}:
  1.0
 -1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/c1a90e53aff91034a8b33ebd5bd6ebd84048d0ef/src/linear_algebra.jl#L75">source</a></section></article><p><code>symbolic_solve</code> only supports symbolic, i.e. non-floating point computations, and thus prefers equations where the coefficients are integer, rational, or symbolic. Floating point coefficients are transformed into rational values and BigInt values are used internally with a potential performance loss, and thus it is recommended that this functionality is only used with floating point values if necessary. In contrast, <code>symbolic_linear_solve</code> directly handles floating point values using standard factorizations.</p><h3 id="More-technical-details-and-examples"><a class="docs-heading-anchor" href="#More-technical-details-and-examples">More technical details and examples</a><a id="More-technical-details-and-examples-1"></a><a class="docs-heading-anchor-permalink" href="#More-technical-details-and-examples" title="Permalink"></a></h3><h4 id="Technical-details"><a class="docs-heading-anchor" href="#Technical-details">Technical details</a><a id="Technical-details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-details" title="Permalink"></a></h4><p>The <code>symbolic_solve</code> function uses 4 hidden solvers in order to solve the user&#39;s input. Its base, <code>solve_univar</code>, uses analytic solutions up to polynomials of degree 4 and factoring as its method for solving univariate polynomials. The function&#39;s <code>solve_multipoly</code> uses GCD on the input polynomials then throws passes the result to <code>solve_univar</code>. The function&#39;s <code>solve_multivar</code> uses Groebner basis and a separating form in order to create linear equations in the input variables and a single high degree equation in the separating variable <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. Each equation resulting from the basis is then passed to <code>solve_univar</code>. We can see that essentially, <code>solve_univar</code> is the building block of <code>symbolic_solve</code>. If the input is not a valid polynomial and can not be solved by the algorithm above, <code>symbolic_solve</code> passes it to <code>ia_solve</code>, which attempts solving by attraction and isolation <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. This only works when the input is a single expression and the user wants the answer in terms of a single variable. Say <code>log(x) - a == 0</code> gives us <code>[e^a]</code>.</p><h4 id="Nice-examples"><a class="docs-heading-anchor" href="#Nice-examples">Nice examples</a><a id="Nice-examples-1"></a><a class="docs-heading-anchor-permalink" href="#Nice-examples" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Symbolics, Nemo;
@variables x;
Symbolics.symbolic_solve(9^x + 3^x ~ 8, x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{SymbolicUtils.BasicSymbolic{Real}}:
 slog(-(1//2) + (1//2)*√(33)) / slog(3)
 slog(-(1//2) - (1//2)*√(33)) / slog(3)</code></pre><pre><code class="language-julia hljs">@variables x y z;
Symbolics.symbolic_linear_solve(2//1*x + y - 2//1*z ~ 9//1*x, 1//1*x)</code></pre><p class="math-container">\[ \begin{equation}
\frac{1}{7} \left( y - 2 z \right)
\end{equation}
 \]</p><pre><code class="language-julia hljs">using Groebner;
@variables x y z;

eqs = [x^2 + y + z - 1, x + y^2 + z - 1, x + y + z^2 - 1]
Symbolics.symbolic_solve(eqs, [x,y,z])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Any}:
 Dict{Num, Any}(z =&gt; 1, y =&gt; 0, x =&gt; 0)
 Dict{Num, Any}(z =&gt; -1 + √(2), y =&gt; -1 + √(2), x =&gt; -1 + √(2))
 Dict{Num, Any}(z =&gt; -1 - √(2), y =&gt; -1 - √(2), x =&gt; -1 - √(2))
 Dict{Num, Any}(z =&gt; 0, y =&gt; 0, x =&gt; 1)
 Dict{Num, Any}(z =&gt; 0, y =&gt; 1, x =&gt; 0)</code></pre><h3 id="Feature-completeness"><a class="docs-heading-anchor" href="#Feature-completeness">Feature completeness</a><a id="Feature-completeness-1"></a><a class="docs-heading-anchor-permalink" href="#Feature-completeness" title="Permalink"></a></h3><ul><li>[x] Linear and polynomial equations</li><li>[x] Systems of linear and polynomial equations</li><li>[x] Some transcendental functions</li><li>[x] Systems of linear equations with parameters (via <code>symbolic_linear_solve</code>)</li><li>[ ] Equations with radicals</li><li>[x] Systems of polynomial equations with parameters and positive dimensional systems</li><li>[ ] Inequalities</li></ul><h3 id="Expressions-we-can-not-solve-(but-aim-to)"><a class="docs-heading-anchor" href="#Expressions-we-can-not-solve-(but-aim-to)">Expressions we can not solve (but aim to)</a><a id="Expressions-we-can-not-solve-(but-aim-to)-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions-we-can-not-solve-(but-aim-to)" title="Permalink"></a></h3><pre><code class="nohighlight hljs"># Mathematica

In[1]:= Reduce[x^2 - x - 6 &gt; 0, x]
Out[1]= x &lt; -2 || x &gt; 3

In[2]:= Reduce[x+a &gt; 0, x]
Out[2]= a \[Element] Reals &amp;&amp; x &gt; -a

In[3]:= Solve[x^(x)  + 3 == 0, x]
Out[3]= {{x -&gt; (I \[Pi] + Log[3])/ProductLog[I \[Pi] + Log[3]]}}</code></pre><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://doi.org/10.1007/s002000050114">Rouillier, F. Solving Zero-Dimensional Systems Through the Rational Univariate Representation. AAECC 9, 433–461 (1999).</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://www.sciencedirect.com/science/article/pii/S0747717189800070">R. W. Hamming, Coding and Information Theory, ScienceDirect, 1980</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../groebner/">« Groebner bases</a><a class="docs-footer-nextpage" href="../arrays/">Symbolic Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 21 October 2024 13:21">Monday 21 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
