<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variable and Equation Types · Symbolics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Symbolics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Symbolics.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/symbolic_functions/">Symbolic Calculations and Building Fast Parallel Functions</a></li><li><a class="tocitem" href="../../tutorials/auto_parallel/">Automated Sparse Parallelism of Julia Functions via Tracing</a></li><li><a class="tocitem" href="../../tutorials/converting_to_C/">Automatic Conversion of Julia Code to C Functions</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Variable and Equation Types</a><ul class="internal"><li><a class="tocitem" href="#Types-1"><span>Types</span></a></li><li><a class="tocitem" href="#A-note-about-functions-restricted-to-Numbers-1"><span>A note about functions restricted to <code>Number</code>s</span></a></li><li><a class="tocitem" href="#Symbolic-Control-Flow-1"><span>Symbolic Control Flow</span></a></li><li><a class="tocitem" href="#Inspection-Functions-1"><span>Inspection Functions</span></a></li></ul></li><li><a class="tocitem" href="../expression_manipulation/">Expression Manipulation</a></li><li><a class="tocitem" href="../derivatives/">Derivatives and Differentials</a></li><li><a class="tocitem" href="../arrays/">Symbolic arrays</a></li><li><a class="tocitem" href="../build_function/">Function Building and Compilation (build_function)</a></li><li><a class="tocitem" href="../functions/">Function Registration and Tracing</a></li><li><a class="tocitem" href="../io/">I/O, Saving, and Latex</a></li><li><a class="tocitem" href="../sparsity_detection/">Structure and Sparsity Detection</a></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li></ul></li><li><a class="tocitem" href="../../comparison/">Comparison Against SymPy</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Variable and Equation Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variable and Equation Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/master/docs/src/manual/variables.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Variable-and-Equation-Types-1"><a class="docs-heading-anchor" href="#Variable-and-Equation-Types-1">Variable and Equation Types</a><a class="docs-heading-anchor-permalink" href="#Variable-and-Equation-Types-1" title="Permalink"></a></h1><p>Symbolics IR mirrors the Julia AST but allows for easy mathematical manipulation by itself following mathematical semantics. The base of the IR is the <code>Sym</code> type, which defines a symbolic variable. Registered (mathematical) functions on <code>Sym</code>s (or <code>istree</code> objects) return an expression that <code>istree</code>. For example, <code>op1 = x+y</code> is one symbolic object and <code>op2 = 2z</code> is another, and so <code>op1*op2</code> is another tree object. Then, at the top, an <code>Equation</code>, normally written as <code>op1 ~ op2</code>, defines the symbolic equality between two operations.</p><h2 id="Types-1"><a class="docs-heading-anchor" href="#Types-1">Types</a><a class="docs-heading-anchor-permalink" href="#Types-1" title="Permalink"></a></h2><p><code>Sym</code>, <code>Term</code>, and <code>FnType</code> are from <a href="https://juliasymbolics.github.io/SymbolicUtils.jl/api/">SymbolicUtils.jl</a>. Note that in Symbolics, we always use <code>Sym{Real}</code>, <code>Term{Real}</code>, and <code>FnType{Tuple{Any}, Real}</code>. To get the arguments of a <code>istree</code> object use <code>arguments(t::Term)</code>, and to get the operation, use <code>operation(t::Term)</code>. However, note that one should never dispatch on <code>Term</code> or test <code>isa Term</code>. Instead, one needs to use <code>SymbolicUtils.istree</code> to check if <code>arguments</code> and <code>operation</code> is defined.</p><article class="docstring"><header><a class="docstring-binding" id="Symbolics.@variables" href="#Symbolics.@variables"><code>Symbolics.@variables</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Define one or more unknown variables.</p><pre><code class="language-julia">@variables t α σ(..) β[1:2]
@variables w(..) x(t) y z(t, α, x)

expr = β[1]* x + y^α + σ(3) * (z - t) - β[2] * w(t - 1)</code></pre><p><code>(..)</code> signifies that the value should be left uncalled.</p><p>Symbolics supports creating variables that denote an array of some size.</p><pre><code class="language-julia">julia&gt; @variables x[1:3]
1-element Vector{Symbolics.Arr{Num, 1}}:
 x[1:3]

julia&gt; @variables y[1:3, 1:6] # support for  tensors
1-element Vector{Symbolics.Arr{Num, 2}}:
 y[1:3,1:6]

julia&gt; @variables t z[1:3](t) # also works for dependent variables
2-element Vector{Any}:
 t
  (map(#5, z))[1:3]</code></pre><p>A symbol or expression that represents an array can be turned into an array of symbols or expressions using the <code>scalarize</code> function.</p><pre><code class="language-julia">julia&gt; Symbolics.scalarize(z)
3-element Vector{Num}:
 z[1](t)
 z[2](t)
 z[3](t)</code></pre><p>Note that <code>@variables</code> returns a vector of all the defined variables.</p><p><code>@variables</code> can also take runtime symbol values by the <code>$</code> interpolation operator, and in this case, <code>@variables</code> doesn&#39;t automatically assign the value, instead, it only returns a vector of symbolic variables. All the rest of the syntax also applies here.</p><pre><code class="language-julia">julia&gt; a, b, c = :runtime_symbol_value, :value_b, :value_c
:runtime_symbol_value

julia&gt; vars = @variables t $a $b(t) $c[1:3](t)
4-element Vector{Any}:
      t
 runtime_symbol_value
   value_b(t)
       (map(#9, value_c))[1:3]

julia&gt; (t, a, b, c)
(t, :runtime_symbol_value, :value_b, :value_c)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/d1a65b378d89baf8c49e9cca45c1997bb686f2a1/src/variable.jl#L278-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Symbolics.Equation" href="#Symbolics.Equation"><code>Symbolics.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Equation</code></pre><p>An equality relationship between two expressions.</p><p><strong>Fields</strong></p><ul><li><p><code>lhs</code></p><p>The expression on the left-hand side of the equation.</p></li><li><p><code>rhs</code></p><p>The expression on the right-hand side of the equation.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/d1a65b378d89baf8c49e9cca45c1997bb686f2a1/src/equations.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:~-Tuple{Num, Num}" href="#Base.:~-Tuple{Num, Num}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">~(lhs::Num, rhs::Num) -&gt; Equation
</code></pre><p>Create an <a href="#Symbolics.Equation"><code>Equation</code></a> out of two <a href="manual/@ref"><code>Num</code></a> instances, or an <code>Num</code> and a <code>Number</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Symbolics

julia&gt; @variables x y;

julia&gt; @variables A[1:3, 1:3] B[1:3, 1:3];

julia&gt; x ~ y
x ~ y

julia&gt; x - y ~ 0
x - y ~ 0

julia&gt; A .~ B
3×3 Array{Equation,2}:
 A₁ˏ₁ ~ B₁ˏ₁  A₁ˏ₂ ~ B₁ˏ₂  A₁ˏ₃ ~ B₁ˏ₃
 A₂ˏ₁ ~ B₂ˏ₁  A₂ˏ₂ ~ B₂ˏ₂  A₂ˏ₃ ~ B₂ˏ₃
 A₃ˏ₁ ~ B₃ˏ₁  A₃ˏ₂ ~ B₃ˏ₂  A₃ˏ₃ ~ B₃ˏ₃

julia&gt; A .~ 3x
3×3 Array{Equation,2}:
 A₁ˏ₁ ~ 3x  A₁ˏ₂ ~ 3x  A₁ˏ₃ ~ 3x
 A₂ˏ₁ ~ 3x  A₂ˏ₂ ~ 3x  A₂ˏ₃ ~ 3x
 A₃ˏ₁ ~ 3x  A₃ˏ₂ ~ 3x  A₃ˏ₃ ~ 3x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/Symbolics.jl/blob/d1a65b378d89baf8c49e9cca45c1997bb686f2a1/src/equations.jl#L29">source</a></section></article><h2 id="A-note-about-functions-restricted-to-Numbers-1"><a class="docs-heading-anchor" href="#A-note-about-functions-restricted-to-Numbers-1">A note about functions restricted to <code>Number</code>s</a><a class="docs-heading-anchor-permalink" href="#A-note-about-functions-restricted-to-Numbers-1" title="Permalink"></a></h2><p><code>Sym</code> and <code>Term</code> objects are NOT subtypes of <code>Number</code>. Symbolics provides a simple wrapper type called <code>Num</code> which is a subtype of <code>Real</code>. <code>Num</code> wraps either a Sym or a Term or any other object, defines the same set of operations as symbolic expressions and forwards those to the values it wraps. You can use <code>Symbolics.value</code> function to unwrap a <code>Num</code>.</p><p>By default, the <code>@variables</code> macros return Num-wrapped objects so as to allow calling functions which are restricted to <code>Number</code> or <code>Real</code>.</p><pre><code class="language-julia">julia&gt; @variables t x y z(t);

julia&gt; Symbolics.operation(Symbolics.value(x + y))
+ (generic function with 377 methods)

julia&gt; Symbolics.operation(Symbolics.value(z))
z(::Any)::Real

julia&gt; Symbolics.arguments(Symbolics.value(x + y))
2-element Vector{Sym{Real}}:
 x
 y</code></pre><h2 id="Symbolic-Control-Flow-1"><a class="docs-heading-anchor" href="#Symbolic-Control-Flow-1">Symbolic Control Flow</a><a class="docs-heading-anchor-permalink" href="#Symbolic-Control-Flow-1" title="Permalink"></a></h2><p>Control flow can be expressed in Symbolics.jl in the following ways:</p><ul><li><code>IfElse.ifelse(cond,x,y)</code>: this is a dispatch-able version of the <code>ifelse</code> function provided by <code>IfElse.jl</code> which allows for encoding conditionals in the symbolic branches.</li></ul><h2 id="Inspection-Functions-1"><a class="docs-heading-anchor" href="#Inspection-Functions-1">Inspection Functions</a><a class="docs-heading-anchor-permalink" href="#Inspection-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicUtils.istree" href="#SymbolicUtils.istree"><code>SymbolicUtils.istree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">istree(x::T)</code></pre><p>Check if <code>x</code> represents an expression tree. If returns true, it will be assumed that <code>operation(::T)</code> and <code>arguments(::T)</code> methods are defined. Definining these three should allow use of <code>simplify</code> on custom types. Optionally <code>symtype(x)</code> can be defined to return the expected type of the symbolic expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicUtils.operation" href="#SymbolicUtils.operation"><code>SymbolicUtils.operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operation(x::T)</code></pre><p>Returns the operation (a function object) performed by an expression tree. Called only if <code>istree(::T)</code> is true. Part of the API required for <code>simplify</code> to work. Other required methods are <code>arguments</code> and <code>istree</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicUtils.arguments" href="#SymbolicUtils.arguments"><code>SymbolicUtils.arguments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arguments(x::T)</code></pre><p>Returns the arguments (a <code>Vector</code>) for an expression tree. Called only if <code>istree(x)</code> is <code>true</code>. Part of the API required for <code>simplify</code> to work. Other required methods are <code>operation</code> and <code>istree</code></p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/converting_to_C/">« Automatic Conversion of Julia Code to C Functions</a><a class="docs-footer-nextpage" href="../expression_manipulation/">Expression Manipulation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 9 July 2021 21:03">Friday 9 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
